<?xml version="1.0" encoding="utf-8"?>
<Script type="xscript4.0"><![CDATA[var SVC_URL  		= "XcommonAction.do?method=XcommonTransaction";
var SVC_USR_URL 	= "XcommonAction.do?method=XcommonUserTransaction";
var SVC_IF_URL 		= "XinterfaceAction.do?method=CommonInterface";
var SVC_CON_URL		= "XcommonAction.do?method=XcommonServerEnv";

var CLASS_TYPE_WAITCURSOR;

var uExtObj = new ExtCommon();

//////////////////////////////////////////////////////////////////////////////////
// 기본함수와의 구별을 위해 첫글자를 대문자로 하였음
// 함수설명 부분에서 Parameter에 있는 (옵션)은 넣어도 되고 안 넣어도 된다는 의미임
// Parameter에 있는 첫글자(예 : nWidth에서의 n)의미 ==> 
//              s = 문자열, n = 숫자형, b = Bool, o = Object, a = Array
// 1. Parameter처리 원칙
//    1) Parameter가 null일 경우 
//       (1) Default처리가 있으면 Default처리 했음 --> Comment참조
//       (2) Default처리가 없는 경우는 아래 실패시 Return처리 원칙에 따름
// 2. 실패시 Return처리 원칙 ( 되도록 null이 return되지 않도록 처리, null되면 죽는 수가 생길 수 있으니까 )
//    1) 문자열 Return의 경우 = ""
//    2) 숫자 Return의 경우 = -1 ( 성공이 0이상인 경우 ), 
//							  NaN ( 성공이 모든 숫자일 경우 )
//    3) Array Return의 경우  = 빈 Array(즉, arr.length=0) 
//    4) Object Return의 경우 = null
//	  5) Boolean Return의 경우 = false
//////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// String & Number Start
////////////////////////////////////////////////////////////////////////////////
/*******************************************************************************
 ★ 설명
    입력값이 null에 해당하는 경우 모두를 한번에 체크한다.
 ★ Parameter 
    1. sValue : 체크할 문자열( 예 : null 또는 undefined 또는 "" 또는 "abc" )
 ★ return 
    - sValue가 undefined, null, NaN, "", Array.length = 0인 경우 = true
    - 이외의 경우 = false
******************************************************************************/
function IsNull(sValue)
{
	if( new String(sValue).valueOf() == "undefined") 
		return true;
	if( sValue == null )
		return true;
	if( ("x"+sValue == "xNaN") && ( new String(sValue.length).valueOf() == "undefined" ) )
		return true;
	if( sValue.length == 0 )
		return true;
	return false;
}

/*******************************************************************************
 ★ 설명
    문자열의 위치를 대소문자 구별하여 찾는다
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbcc" )
    2. sFind  : 찾고자 하는 문자열( 예 : "bb" )
    3. nStart : 검색 시작위치 (옵션 : Default=0) ( 예 : 1 )
 ★ return 
    - 성공 = 찾고자 하는 문자열의 시작위치 ( 예 : 4 )
    - 실패 = -1
 ******************************************************************************/
function Pos(sOrg, sFind, nStart)
{
	if( IsNull(sOrg) || IsNull(sFind) )		return -1;
	if( IsNull(nStart) )		nStart = 0;
		
	return sOrg.indexOf(sFind, nStart);
}

/*******************************************************************************
 ★ 설명
    문자열의 위치를 대소문자 구별없이 찾는다
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbcc" )
    2. sFind  : 찾고자 하는 문자열( 예 : "bb" )
    3. nStart : 검색 시작위치 (옵션 : Default=0) ( 예 : 1 )    
 ★ return 
    - 성공 = 찾고자 하는 문자열의 시작위치 ( 예 : 2 )
    - 실패 = -1
 ******************************************************************************/
function PosCase(sOrg, sFind, nStart)
{
	if( IsNull(sOrg) || IsNull(sFind) )		return -1;
	if( IsNull(nStart) )		nStart = 0;
	
	return sOrg.toLowerCase().indexOf(sFind.toLowerCase(), nStart);
}

/*******************************************************************************
 ★ 설명
    문자열의 위치를 대소문자 구별하여 거꾸로 찾는다
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbcc" )
    2. sFind  : 찾고자 하는 문자열( 예 : "BB" )
    3. nStart : 검색 시작위치 (옵션 : Default=문자열의 끝 ) ( 예 : 6 )
 ★ return 
    - 성공 = 찾고자 하는 문자열의 시작위치 ( 예 : 2 )
    - 실패 = -1
 ******************************************************************************/
function PosReverse(sOrg, sFind, nStart)
{
	var pos;
	
	if( IsNull(sOrg) || IsNull(sFind) )		return -1;	
	if( IsNull(nStart) )		nStart = sOrg.length-1;

	for( pos = nStart ; pos >= 0 ; pos-- )
	{
		if( sOrg.substr( pos, sFind.length ) == sFind )
			break;
	}
	
	return pos;
}

/*******************************************************************************
 ★ 설명
    문자열의 위치를 대소문자 구별없이 거꾸로 찾는다
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbcc" )
    2. sFind  : 찾고자 하는 문자열( 예 : "BB" )
    3. nStart : 검색 시작위치 (옵션 : Default=문자열의 끝 ) ( 예 : 6 )
 ★ return 
    - 성공 = 찾고자 하는 문자열의 시작위치 ( 예 : 4 )
    - 실패 = -1
 ******************************************************************************/
function PosReverseCase(sOrg, sFind, nStart)
{
	var pos;
	
	if( IsNull(sOrg) || IsNull(sFind) )		return -1;	
	if( IsNull(nStart) )		nStart = sOrg.length-1;

	for( pos = nStart ; pos >= 0 ; pos-- )
	{
		if( sOrg.substr( pos, sFind.length ).toLowerCase() == sFind.toLowerCase() )
			break;
	}
	
	return pos;
}

/*******************************************************************************
 ★ 설명
    시작글자와 끝글자에 해당하는 글자의 사이에 있는 가운데 글자를 
    대소문자를 구별하여 찾는다.
    ( 예 : aaBBbbccdd에서 bb, dd사이의 글자 cc를 찾는다 )
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbccdd" )
    2. sStart : 찾고자 하는 시작 문자열(옵션 : Default = "")(예 : "bb" )
                (만일, sStart=""이면 nStart부터 sEnd까지의 모든 문자열이 return된다.)
    3. sEnd   : 찾고자 하는 끝 문자열 (옵션 : Default = "")( 예 : "dd" ) 
				(만일, sEnd=""이면 sStart부터 문자열의 끝까지의 모든 문자열이 return된다.)
	4. nStart : 검색 시작위치 (옵션 : Default=0) ( 예 : 1 )
 ★ return 
    - 성공 = 가운데 글자 ( 예 : "cc" )
    - 실패 = ""
 ******************************************************************************/
function Mid(sOrg, sStart, sEnd, nStart)
{
	var pos_start, pos_end, ret_str;
	
	if( IsNull(sOrg) )		return "";	
	if( IsNull(sStart) )	sStart = "";
	if( IsNull(sEnd) )		sEnd = "";
	if( IsNull(nStart) )	nStart = 0;
		
	if( sStart == "" )
		pos_start = nStart;
	else
	{
		pos_start = Pos(sOrg, sStart, nStart);
		if( pos_start < 0 )	return "";
	}
	if( sEnd == "" )
		pos_end = sOrg.length;
	else
	{
		pos_end = Pos(sOrg, sEnd, pos_start+sStart.length, nStart);
		if( pos_end < 0 )	return "";
	}

	return sOrg.substring(pos_start+sStart.length, pos_end);
}

/*******************************************************************************
 ★ 설명
    시작글자와 끝글자에 해당하는 글자의 사이에 있는 가운데 글자를 
    대소문자 구별없이 찾는다.
    ( 예 : aaBBbbccdd에서 bb, dd사이의 글자 bbcc를 찾는다 )
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbccdd" ) 
    2. sStart : 찾고자 하는 시작 문자열(옵션 : Default = "")(예 : "bb" )
                (만일, sStart=""이면 nStart부터 sEnd까지의 모든 문자열이 return된다.)
    3. sEnd   : 찾고자 하는 끝 문자열 (옵션 : Default = "")( 예 : "dd" ) 
				(만일, sEnd=""이면 sStart부터 문자열의 끝까지의 모든 문자열이 return된다.)
	4. nStart : 검색 시작위치 (옵션 : Default=0) ( 예 : 1 )               
 ★ return 
    - 성공 = 가운데 글자 ( 예 : "bbcc" )
    - 실패 = ""
 ******************************************************************************/
function MidCase(sOrg, sStart, sEnd, nStart)
{
	var pos_start, pos_end, ret_str;
	
	if( IsNull(sOrg) )		return "";	
	if( IsNull(sStart) )	sStart = "";
	if( IsNull(sEnd) )		sEnd = "";
	if( IsNull(nStart) )	nStart = 0;
		
	if( sStart == "" )
		pos_start = nStart;
	else
	{
		pos_start = PosCase(sOrg, sStart, nStart);
		if( pos_start < 0 )	return "";
	}
	if( sEnd == "" )
		pos_end = sOrg.length;
	else
	{
		pos_end = PosCase(sOrg, sEnd, pos_start+sStart.length, nStart);
		if( pos_end < 0 )	return "";
	}

	return sOrg.substring(pos_start+sStart.length, pos_end);
}

/*******************************************************************************
 ★ 설명
    Mid()함수와 동일하나 Return을 Array로 한다.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbccdd" ) 
    2. sStart : 찾고자 하는 시작 문자열(옵션 : Default = "")(예 : "bb" )
                (만일, sStart=""이면 nStart부터 sEnd까지의 모든 문자열이 return된다.)
    3. sEnd   : 찾고자 하는 끝 문자열 (옵션 : Default = "")( 예 : "dd" ) 
				(만일, sEnd=""이면 sStart부터 문자열의 끝까지의 모든 문자열이 return된다.)
	4. nStart : 검색 시작위치 (옵션 : Default=0) ( 예 : 1 )               
 ★ return 
    - 성공
      Array[0] = 가운데 글자 ( 예 : "cc" )
      Array[1] = sStart의 위치 ( 예 : 4 )
      Array[2] = sEnd의 위치 ( 예 : 8 )
    - 실패 
      Array[0] = ""
      Array[1] = -1
      Array[2] = -1
 ★ 목적       
    sStart, sEnd의 위치를 알아내려면 다시한번 찾아야 하므로 속도 때문에 만들었다. 
 ******************************************************************************/
function AMid(sOrg, sStart, sEnd, nStart)
{
	var pos_start, pos_end, ret_str;
	var arr = new Array("",-1,-1);
	
	if( IsNull(sOrg) )		return "";	
	if( IsNull(sStart) )	sStart = "";
	if( IsNull(sEnd) )		sEnd = "";
	if( IsNull(nStart) )	nStart = 0;
		
	if( sStart == "" )
		pos_start = nStart;
	else
	{
		pos_start = Pos(sOrg, sStart, nStart);
		if( pos_start < 0 )	return arr;
	}
	if( sEnd == "" )
		pos_end = sOrg.length;
	else
	{
		pos_end = Pos(sOrg, sEnd, pos_start+sStart.length, nStart);
		if( pos_end < 0 )	return arr;
	}
	
	arr[0] = sOrg.substring(pos_start+sStart.length, pos_end);
	arr[1] = pos_start;
	arr[2] = pos_end;
	return arr;
}

/*******************************************************************************
 ★ 설명
    MidCase()함수와 동일하나 Return을 Array로 한다.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbccdd" ) 
    2. sStart : 찾고자 하는 시작 문자열(옵션 : Default = "")(예 : "bb" )
                (만일, sStart=""이면 nStart부터 sEnd까지의 모든 문자열이 return된다.)
    3. sEnd   : 찾고자 하는 끝 문자열 (옵션 : Default = "")( 예 : "dd" ) 
				(만일, sEnd=""이면 sStart부터 문자열의 끝까지의 모든 문자열이 return된다.)
	4. nStart : 검색 시작위치 (옵션 : Default=0) ( 예 : 1 )               
 ★ return 
    - 성공
      Array[0] = 가운데 글자 ( 예 : "bbcc" )
      Array[1] = sStart의 위치 ( 예 : 2 )
      Array[2] = sEnd의 위치 ( 예 : 8 )
    - 실패 
      Array[0] = ""
      Array[1] = -1
      Array[2] = -1
 ★ 목적       
    sStart, sEnd의 위치를 알아내려면 다시한번 찾아야 하므로 속도 때문에 만들었다. 
 ******************************************************************************/
function AMidCase(sOrg, sStart, sEnd, nStart)
{
	var pos_start, pos_end, ret_str;
	var arr = new Array("",-1,-1);
	
	if( IsNull(sOrg) )		return "";	
	if( IsNull(sStart) )	sStart = "";
	if( IsNull(sEnd) )		sEnd = "";
	if( IsNull(nStart) )	nStart = 0;
		
	if( sStart == "" )
		pos_start = nStart;
	else
	{
		pos_start = PosCase(sOrg, sStart, nStart);
		if( pos_start < 0 )	return arr;
	}
	if( sEnd == "" )
		pos_end = sOrg.length;
	else
	{
		pos_end = PosCase(sOrg, sEnd, pos_start+sStart.length, nStart);
		if( pos_end < 0 )	return arr;
	}
	
	arr[0] = sOrg.substring(pos_start+sStart.length, pos_end);
	arr[1] = pos_start;
	arr[2] = pos_end;
	return arr;
}

/*******************************************************************************
 ★ 설명
    문자열을 대소문자 구별하여 치환한다
 ★ Parameter 
    1. sOrg   : 원래문자열 (예 : "aaBBbbccBB" )
    2. sRepFrom : 치환할 문자열 ( 예 : "BB" )
    3. sRepTo : 치환될 문자열 ( 예 : "xx" )
 ★ return 
    - 성공 = 치환된 문자열 ( 예 : "aaxxbbccxx" )
    - 실패 = sOrg
 ******************************************************************************/
function Replace( sOrg, sRepFrom, sRepTo )
{
	var pos, nStart=0, sRet="";
	
	if( IsNull(sOrg) )			return "";
	if( IsNull(sRepFrom) )		return sOrg;
	if( IsNull(sRepTo) )		return sOrg;
		
	while(1)
	{
		pos = Pos( sOrg, sRepFrom, nStart );
		if( pos < 0 )
		{
			sRet += sOrg.substr( nStart );
			break;
		}
		else
		{
			sRet += sOrg.substr( nStart, pos - nStart);
			sRet += sRepTo;
			nStart = pos+sRepFrom.length;
		}
	}
	return sRet;
}

/*******************************************************************************
 ★ 설명
    문자열을 대소문자 구별없이 치환한다
 ★ Parameter 
    1. sOrg   : 원래문자열 (예 : "aaBBbbccBB" )
    2. sRepFrom : 치환할 문자열 ( 예 : "BB" )
    3. sRepTo : 치환될 문자열 ( 예 : "xx" )
 ★ return 
    - 성공 = 치환된 문자열 ( 예 : "aaxxxxccxx" )
    - 실패 = sOrg
 ******************************************************************************/
function ReplaceCase( sOrg, sRepFrom, sRepTo )
{
	var pos, nStart=0, sRet="";
	
	if( IsNull(sOrg) )			return "";	
	if( IsNull(sRepFrom) )		return sOrg;
	if( IsNull(sRepTo) )		return sOrg;
		
	while(1)
	{
		pos = PosCase( sOrg, sRepFrom, nStart );
		if( pos < 0 )
		{
			sRet += sOrg.substr( nStart );
			break;
		}
		else
		{
			sRet += sOrg.substr( nStart, pos - nStart);
			sRet += sRepTo;
			nStart = pos+sRepFrom.length;
		}
	}
	return sRet;
}

function trim(sOrg){
	return RTrim(LTrim(sOrg," ")," ");
}

/*******************************************************************************
 ★ 설명
    대소문자 구별하여 왼쪽에서 문자열 삭제.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "BBbbcc" )
    2. sTrim  : Trim할 문자열(옵션 : Default=" ") ( 예 : "bb" )
 ★ return 
    - 성공 = Trim된 문자열 ( 예 : "bbcc" )
    - 실패 = ""
 ******************************************************************************/
function LTrim(sOrg, sTrim)
{
	var chk, pos;

	if( IsNull(sOrg) )		return "";
	if( IsNull(sTrim) )		sTrim = " ";

	for( pos = 0 ; pos < sOrg.length ; pos+=sTrim.length )
	{
		if( sOrg.substr( pos, sTrim.length ) != sTrim )
			break;
	}
	
	return sOrg.substr(pos);
}

/*******************************************************************************
 ★ 설명
    대소문자 구별없이 왼쪽에서 문자열 삭제.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "BBbbcc" )
    2. sTrim  : Trim할 문자열(옵션 : Default=" ")( 예 : "bb" )
 ★ return 
    - 성공 = Trim된 문자열 ( 예 : "cc" )
    - 실패 = ""
 ******************************************************************************/
function LTrimCase(sOrg, sTrim)
{
	var pos;

	if( IsNull(sOrg) )		return "";
	if( IsNull(sTrim) )		sTrim = " ";
			
	for( pos = 0 ; pos < sOrg.length ; pos+=sTrim.length )
	{
		if( sOrg.toLowerCase().substr( pos, sTrim.length ) != sTrim.toLowerCase() )
			break;
	}
	
	return sOrg.substr(pos);
}

/*******************************************************************************
 ★ 설명
    대소문자 구별하여 오른쪽에서 문자열 삭제.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "bbccCC" )
    2. sTrim  : Trim할 문자열(옵션 : Default=" ")( 예 : "CC" )
 ★ return 
    - 성공 = Trim된 문자열 ( 예 : "bbcc" )
    - 실패 = ""
 ******************************************************************************/
function RTrim(sOrg, sTrim)
{
	var pos, nStart;

	if( IsNull(sOrg) )		return "";
	if( IsNull(sTrim) )		sTrim = " ";
		
	for( pos = sOrg.length-sTrim.length ; pos >= 0 ; pos -= sTrim.length )
	{
		if( sOrg.substr( pos, sTrim.length ) != sTrim )
			break;
	}

	return sOrg.substr(0, pos+sTrim.length);
}

/*******************************************************************************
 ★ 설명
    대소문자 구별없이 오른쪽에서 문자열 삭제.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "bbccCC" )
    2. sTrim  : Trim할 문자열(옵션 : Default=" ")( 예 : "CC" )
 ★ return 
    - 성공 = Trim된 문자열 ( 예 : "bb" )
    - 실패 = ""
 ******************************************************************************/
function RTrimCase(sOrg, sTrim)
{
	var pos, nStart;

	if( IsNull(sOrg) )		return "";
	if( IsNull(sTrim) )		sTrim = " ";
		
	for( pos = sOrg.length-sTrim.length ; pos >= 0 ; pos -= sTrim.length )
	{
		if( sOrg.toLowerCase().substr( pos, sTrim.length ) != sTrim.toLowerCase() )
			break;
	}

	return sOrg.substr(0, pos+sTrim.length);
}

/*******************************************************************************
 ★ 설명
    왼쪽에 문자열 추가.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "bbccCC" )
    2. sPad   : Pad할 문자열(옵션 : Default=" ")( 예 : "aa" )
    3. nCnt   : 반복횟수(옵션 : Default=1) (예 : 2)
 ★ return 
    - 성공 = Pad된 문자열 ( 예 : "aaaabbccCC" )
    - 실패 = ""
 ******************************************************************************/
function LPad(sOrg, sPad, nCnt)
{
	var i, sRet="";

	if( IsNull(sOrg) )		return "";
	if( IsNull(sPad) )		sPad = " ";
	if( IsNull(nCnt) )		nCnt = 1;

	for( i = 0 ; i < nCnt ; i++ )
		sRet += sPad;
	sRet += sOrg;
	
	return sRet;
}

/*******************************************************************************
 ★ 설명
    오른쪽에 문자열 추가.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "bbccCC" )
    2. sPad   : Pad할 문자열(옵션 : Default=" ")( 예 : "aa" )
    3. nCnt   : 반복횟수(옵션 : Default=1) (예 : 2)
 ★ return 
    - 성공 = Pad된 문자열 ( 예 : "bbccCCaaaa" )
    - 실패 = ""
 ******************************************************************************/
function RPad(sOrg, sPad, nCnt)
{
	var i, sRet="";

	if( IsNull(sOrg) )		return "";
	if( IsNull(sPad) )		sPad = " ";
	if( IsNull(nCnt) )		nCnt = 1;
	
	sRet += sOrg;
	for( i = 0 ; i < nCnt ; i++ )
		sRet += sPad;
	
	return sRet;
}

/*******************************************************************************
 ★ 설명
    문자열의 오른쪽에서 nSize만큼의 문자열을 가져온다.
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbcc" )
    2. nSize  : 가져올문자열 길이 ( 예 : 2 )
 ★ return 
    - 성공 = 오른쪽에서 nSize만큼의 문자열 ( 예 : "cc" )
    - 실패 = ""
 ★ 주의사항
    sOrg의 길이가 nSize보다 작은경우는 sOrg가 Return된다.
    ( 예 : sOrg="a", nSize=2 ==> return = "a" )
 ******************************************************************************/
function Right(sOrg, nSize)
{
	if( IsNull(sOrg) || IsNull(nSize) )		return "";
	
	if( sOrg.length < nSize )
		return sOrg;
	else
		return sOrg.substr(sOrg.length-nSize, nSize);
}

/*******************************************************************************
 ★ 설명
    대소문자 구별하여 문자개수 세기
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbcc" )
    2. sCnt   : 개수를 셀 문자열 ( 예 : "BB" )
 ★ return 
    - 성공 = 문자개수 ( 예 : 1 )
    - 실패 = -1
 ******************************************************************************/
function Count(sOrg, sCnt)
{
	var i, sRet="";
	var nCnt = 0;

	if( IsNull(sOrg) || IsNull(sCnt) )		return -1;
	
	for( i = 0 ; i < sOrg.length ; i += sCnt.length )
	{
		if( sOrg.substr(i, sCnt.length) == sCnt )
			nCnt++;
	}
	
	return nCnt;
}

/*******************************************************************************
 ★ 설명
    대소문자 구분없이 문자개수 세기
 ★ Parameter 
    1. sOrg   : 원래 문자열( 예 : "aaBBbbcc" )
    2. sCnt   : 개수를 셀 문자열 ( 예 : "BB" )
 ★ return 
    - 성공 = 문자개수 ( 예 : 2 )
    - 실패 = -1
 ******************************************************************************/
function CountCase(sOrg, sCnt)
{
	var i, sRet="";
	var nCnt = 0;

	if( IsNull(sOrg) || IsNull(sCnt) )		return -1;
		
	for( i = 0 ; i < sOrg.length ; i += sCnt.length )
	{
		if( sOrg.toLowerCase().substr(i, sCnt.length) == sCnt.toLowerCase() )
			nCnt++;
	}
		
	return nCnt;
}

/*******************************************************************************
 ★ 설명
    문자 전체 길이를 계산
      - 문자, 숫자, 특수문자 : 1 로 Count	
	  - 그외 한글/한자 : 2 로 count 되어 합산한다.
 ★ Parameter 
    1. sVal   : 입력받은 문자열 ( 예 : "a1\n한韓" )
 ★ return 
    - 성공 = 길이 ( 예 : 7 )
    - 실패 = -1
 ******************************************************************************/
function LenB(sVal)
{
    var len = 0;
   
	if( IsNull(sVal) ) 	return -1;
	
    for (i=0; i<sVal.length; i++)
    {
        if (sVal.charCodeAt(i) > 127)
            len += 2;
        else 
            len += 1;
    }
	
	return len;
}

/*******************************************************************************
 ★ 설명
    전각문자를 반각문자로
    ( 참고 : 전각문자는 "정사각형" 안에 들어가는 문자이고, 반각은 그 정사각형의 반쪽에 들어가는 문자이다.
             전각문자의 폭은, 반각문자의 2배입니다. 
             예를 들어 숫자 "3" 은, 한글 "가"의 절반의 폭만을 가지고 있습니다. 
             그래서 영문과 숫자 등은 반각이고, 한글이나 한자들은 전각문자입니다. 
             다만, 영문과 숫자를 전각으로 표현할 수도 있습니다.
      예 : 전각문자 ==> ※★０＋
           반각문자 ==> 1a )
 ★ Parameter 
    1. sFull   : 전각문자( 예 : "０＋" )
 ★ return 
    - 성공 = 반각문자 ( 예 : "0+" )
    - 실패 = ""
 ******************************************************************************/
function Full2Half(sFull)
{
	var i, c, sHalf = "";
  
	if( IsNull(sFull) )		return "";
	
	for( i=0 ; i < sFull.length ; i++ )
	{
		var c = sFull.charCodeAt(i);

		if (c == 12288) 
			sHalf += unescape("%20"); 
		else if ( (c >= 65281) && (c <= 65374) ) 
			sHalf += unescape("%"+(c-65248).toString(16));
		else 
			sHalf += sFull.charAt(i);
	}
	return  sHalf;
}

/*******************************************************************************
 ★ 설명
    반각문자를 전각문자로
 ★ Parameter 
    1. sHalf   : 반각문자( 예 : "0+" )
 ★ return 
    - 성공 = 전각문자 ( 예 : "０＋" )
    - 실패 = ""
 ******************************************************************************/
function Half2Full(sHalf)
{
    var rTmp = "";
    var iTmp = "";
    var i;
 
 	if( IsNull(sHalf) )		return "";
 	
    for( i = 0 ; i < sHalf.length ; i++ ) 
    {
        //기본 아스키 코드 값을 벗어난 경우(한글)는 전자로 변환할 필요 없음.
        if( (sHalf.charCodeAt(i) >= 32) && (sHalf.charCodeAt(i) <= 126) ) 
        {
			if( sHalf.charCodeAt(i) == 32 ) 
				iTmp = unescape("%u"+(12288).toString(16));
            else 
				iTmp = sHalf.charCodeAt(i) + 65248;
		}
        else 
            iTmp = sHalf.charCodeAt(i);

		if( sHalf.charCodeAt(i) == 32 ) 
			rTmp = rTmp + (iTmp);
		else 
			rTmp = rTmp + String.fromCharCode(iTmp);
    }

    return rTmp;
}


/*******************************************************************************
 ★ 설명
    문자열이 숫자형식에 맞는지 여부 체크
 ★ Parameter 
    1. sNum   : 체크할 문자열숫자 ( 예 : "-1234.56" ) (단, ","가 들어있으면 안 됨)
 ★ return 
    - 숫자형식에 맞는경우 = true
    - 숫자형식에 맞지않는 경우 = false
 ******************************************************************************/
function IsNum(sNum)
{
	var c;
	var point_cnt=0;
	var ret=true;
	
	if( IsNull(sNum) )		return false;
	
	for( i = 0 ; i < sNum.length ; i++ )
	{
		c = sNum.charAt(i);
		if( i == 0 && ( c == "+" || c == "-" ) );
		else if( c >= "0" && c <= "9" );
		else if( c == "." )
		{
			point_cnt++;
			if( point_cnt > 1 )
			{
				ret = false;
				break;
			}
		}
		else
		{
			ret = false;
			break;
		}
	}
	
	return ret;
}

/*******************************************************************************
 ★ 설명
    문자열이 알파벳(a~z, A~Z)만으로 구성되어 있는지 체크
 ★ Parameter 
    1. sVal   : 체크할 문자열 ( 예 : "aAzZ" ) 
 ★ return 
    - 알파벳만 있는경우 = true
    - 알파벳이 아닌 글자가 하나라도 있는 경우 = false
 ******************************************************************************/
function IsAlpha(sVal)
{
	if( IsNull(sVal) )		return false;
	
	if( sVal.search("[^A-Za-z]") >= 0 )
		return false;
	else
		return true;
}

/*******************************************************************************
 ★ 설명
    문자열이 알파벳(a~z, A~Z), 숫자만으로 구성되어 있는지 체크
 ★ Parameter 
    1. sVal   : 체크할 문자열 ( 예 : "aAzZ09" ) 
 ★ return 
    - 알파벳, 숫자만 있는경우 = true
    - 알파벳, 숫자가 아닌 글자가 하나라도 있는 경우 = false
 ******************************************************************************/
function IsAlNum(sVal)
{
	if( IsNull(sVal) )		return false;

	if( sVal.search("[^A-Za-z0-9]") >= 0 )
		return false;
	else
		return true;
}

/*******************************************************************************
 ★ 설명
    문자열이 한글로만 구성되어 있는지 체크
 ★ Parameter 
    1. sVal   : 체크할 문자열 ( 예 : "가나다" ) 
 ★ return 
    - 한글만 있는경우 = true
    - 한글이 아닌 글자가 하나라도 있는 경우 = false
 ******************************************************************************/
function IsKor(sVal)
{
	var i;
	
	if( IsNull(sVal) )		return false;
		
	for( i = 0 ; i < sVal.length ; i++ )
	{
		if( !((sVal.charCodeAt(i) > 0x3130 && sVal.charCodeAt(i) < 0x318F) || (sVal.charCodeAt(i) >= 0xAC00 && sVal.charCodeAt(i) <= 0xD7A3)))
			return false;
	}
	
	return true;
}

/*******************************************************************************
 ★ 설명
    숫자에 ","를 집어넣기
 ★ Parameter 
    1. sNum   : 숫자( 예 : -1234567.89 )
 ★ return 
    - 성공 = ","가 들어간 문자열 ( 예 : -1,234,567.89 )
    - 실패 = ""
 ******************************************************************************/
function SetComma(sNum)
{
	var ppos, sDigit, nEnd, nStart=0, sRet="";
	
	if( IsNull(sNum) )	return "";
	
	if( sNum.charAt(0) == "+" || sNum.charAt(0) == "-" )
	{
		sRet += sNum.charAt(0);
		nStart = 1;
	}
	ppos = Pos(sNum, ".", nStart);
	if( ppos < 0 )
		nEnd = sNum.length;
	else
		nEnd = ppos;
	sDigit = sNum.substr(nStart, nEnd-nStart);
	for( pos = 0 ; pos < sDigit.length ; pos ++ )
	{
		if( pos != 0 && (sDigit.length-pos)%3 == 0 )
			sRet += ",";
		sRet += sDigit.charAt(pos);
	}
	sRet += sNum.substr(nEnd);
	
	return sRet;
}

/*******************************************************************************
 ★ 설명
    정수인 nStart ~ nEnd의 범위에 있는 숫자에 대하여 random값을 return한다.
 ★ Parameter 
    1. nStart : 시작숫자 ( 단, 정수, 만일 정수가 아니면 Math.floor(nStart)를 적용함)
    2. nEnd   : 끝숫자 ( 단, 정수, 만일 정수가 아니면 Math.floor(nStart)를 적용함)
 ★ return 
    - 성공 = nStart ~ nEnd범위 중 random숫자 (단, nStart, nEnd도 포함됨)
    - 실패 = -1
 ★ 목적
    1. Math.random()이 0 ~ 1사이만 나와서 불편해서 만들었음
    2. Math.random()은 처음에 0.5근처만 나와서 만들었음
 ★ 주의사항
    nStart, nEnd는 정수임에 주의
 ******************************************************************************/
function Rand(nStart, nEnd)
{
	var range_unit, rand, tmp;
	
	if( IsNull(nStart) || IsNull(nEnd) )	return -1;
		
	nStart = Math.floor(nStart);
	nEnd = Math.floor(nEnd);
	if( nStart > nEnd )
	{
		tmp = nStart;
		nStart = nEnd;
		nEnd = tmp;
	}
	range_unit = nEnd-nStart+1;
	

	var dt = new Date();
	rand = (dt.getMilliseconds()+(Math.random()*2000))/3000;

	return Math.floor(rand*range_unit*2)%range_unit+nStart;
}

/*******************************************************************************
 ★ 설명
    Degree를 Radian으로 변환
 ★ parameter 
    1. nDegree : Degree값(예: 180, 90,...)
 ★ return 
    1. 성공 = Radian(예:Math.PI, Math.PI/2,...)
    2. 실패 = NaN
******************************************************************************/ 
function Deg2Rad(nDegree)
{
	return (Math.PI/180)*nDegree;
}

/*******************************************************************************
 ★ 설명
    Radian을 Degree로 변환
 ★ parameter 
    1. nRadian : Radian값(예:Math.PI, Math.PI/2,...)
 ★ return 
    1. 성공 = Degree(예: 180, 90,...)
    2. 실패 = NaN
******************************************************************************/ 
function Rad2Deg(nRadian)
{
	return (180/Math.PI)*nRadian;
}

/*******************************************************************************
 ★ 설명
    화면좌표에서 nBase(X,Y)를 지나는 가로선 대비 n(X,Y)좌표를 Radian각으로 구한다.
 ★ parameter 
    1. nBaseX, nBaseY : 기준 X, Y좌표
    2. nX, nY : X, Y좌표
 ★ return 
    1. 성공 = Radian(예: Math.PI, ...)
    2. 실패 = NaN
******************************************************************************/ 
function GetAngle(nBaseX, nBaseY, nX, nY)
{
	return Math.atan2((nBaseY-nY),(nX-nBaseX));
}

/*******************************************************************************
 ★ 설명
    Array에 있는 값들을 Distinct(중복제거)한다.
 ★ Parameter 
    1. aOrg   : 중복을 제거할 원래 Array ( 예 : (1,1,2,2,3,4,5) )
 ★ return 
    - 성공 = 중복이 제거된 Array ( 예 : (1,2,3,4,5) )
    - 실패 = 빈 Array()
 ******************************************************************************/
function Distinct(aOrg)
{
	var i, j;
	var flag;
	var aDist=new Array();
	var vDist;
	
	if( IsNull(aOrg) )		return aDist;
	
	for( i = 0 ; i < aOrg.length ; i++ )
	{
		vDist = aOrg[i];
		flag = false;
		for( j = 0 ; j < aDist.length ; j++ )
		{
			if( "x"+aDist[j] == "x"+vDist )
			{
				flag = true;
				break;
			}
		}
		if( flag == false )
			aDist[aDist.length] = vDist;			
	}
	
	return aDist;	
}

////////////////////////////////////////////////////////////////////////////////
// String & Number Start
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// File Start
////////////////////////////////////////////////////////////////////////////////
/*******************************************************************************
 ★ 설명
    File Path 문자열(예 : C:\a\b\filename.ext)에서 File명(예 : filename)을 추출
 ★ Parameter 
    1. sPath   : File Path 문자열 (예 : "C:\a\b\filename.ext")
    2. bExt    : extend를 return되는 File명에 포함시킬지 여부 ( 옵션 : Default=false )
                 - true : extend를 File명에 포함시킴
                 - false : extend를 File명에 포함시키지 않음
 ★ return 
    - 성공 =
		- bExt = true인 경우 ==> sPath에서 File명(예 : "filename.ext")
		- bExt = false인 경우 ==> sPath에서 File명(예 : "filename")
	- 실패 = ""
 ******************************************************************************/
function GetFileName( sPath, bExt )
{
	var start_pos, end_pos, tmp_pos, filename;

	if( IsNull(sPath) )		return "";
	if( IsNull(bExt) )
		bExt = false;
	
	start_pos = Math.max(PosReverse( sPath, "\\" ), 
						PosReverse( sPath, "/" ));
    tmp_pos = PosReverse( sPath, "::");
	if( tmp_pos > 0 ) tmp_pos++;
	start_pos = Math.max( start_pos, tmp_pos );
	if( bExt == false )
	{
		end_pos = PosReverse( sPath, "." );
		if( end_pos < 0 )
			end_pos = sPath.length;
		filename = sPath.substr( start_pos+1, end_pos-start_pos-1 );
	}
	else
	{
		filename = sPath.substr( start_pos+1 );
	}
		
	return filename;
}



////////////////////////////////////////////////////////////////////////////////
// File End
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Date Start
////////////////////////////////////////////////////////////////////////////////


/**********************************************************************************
 ★ 설명
    해당월의 마지막 날짜를 숫자로 구하기 
 ★ parameter 
    1. sDate : yyyyMMdd형태의 날짜 ( 예 : "20121122" )
 ★ return 
    - 성공 = 마지막 날짜 숫자값 ( 예 : 30 )
    - 실패 = -1
**********************************************************************************/
function LastDateNum(sDate)
{
    var nMonth, nLastDate;

	if( IsNull(sDate) )		return -1;
	
	nMonth = parseInt(sDate.substr(4,2), 10);
    if( nMonth == 1 || nMonth == 3 || nMonth == 5 || nMonth == 7  || nMonth == 8 || nMonth == 10 || nMonth == 12 )
		nLastDate = 31;
    else if( nMonth == 2 )  
    {
        if( IsLeapYear(sDate) == true )
			nLastDate = 29;
        else
			nLastDate = 28;
    } 
    else 
		nLastDate = 30;
		
	return nLastDate;
}

/*******************************************************************************
 ★ 설명
    윤년여부 확인
 ★ parameter 
    sDate : yyyyMMdd형태의 날짜 ( 예 : "20121122" )
 ★ return 
    - sDate가 윤년인 경우 = true
    - sDate가 윤년이 아닌 경우 = false
    - sDate가 입력되지 않은 경우 = false
******************************************************************************/  
function IsLeapYear(sDate)
{
    var ret;
    var nY;
    
    if( IsNull(sDate) )		return false;
    
    nY = parseInt(sDate.substring(0,4), 10);

    if ((nY % 4) == 0) 
    {
        if ((nY % 100) != 0 || (nY % 400) == 0) 
            ret = true;
        else 
            ret = false;
    } 
    else 
        ret = false;
  
    return ret;
}

/**********************************************************************************
 ★ 설명
    해당월의 마지막 날짜를 yyyyMMdd형태로 구하기 
 ★ parameter 
    1. sDate : yyyyMMdd형태의 날짜 ( 예 : "20121122" )
 ★ return 
    - 성공 = yyyyMMdd형태의 마지막 날짜 ( 예 : "20121130" )
    - 실패 = ""
**********************************************************************************/
function LastDate(sDate)
{
	if( IsNull(sDate) )		return "";
	
	var nLastDate = LastDateNum(sDate);
	
	return sDate.substr(0,6) + nLastDate.toString();
}

/*******************************************************************************
 ★ 설명
    날짜 형식이 맞는지 확인
 ★ parameter 
    sDate : yyyyMMdd형태의 날짜 ( 예 : "20121122" )
 ★ return 
    - 날짜형식이 맞는 경우 = true
    - 날짜형식이 맞지 않는 경우 = false
    - sDate가 입력되지 않은 경우 = false
******************************************************************************/  
function IsDate(sDate)
{	
	if( IsNull(sDate) )		return false;
	
    if( sDate.length != 8 )
        return false;
    
    if( IsNum(sDate) != true )
        return false;
    
	var nMonth  = parseInt(sDate.substring(4,6), 10);
	var nDate  = parseInt(sDate.substring(6,8), 10);
    
    if( nMonth < 1 || nMonth > 12 ) 
        return false;
        
    if( nDate < 1 || nDate > LastDateNum(sDate) )
        return false;
    
    return true;
}

/**********************************************************************************
 ★ 설명
    숫자로 된 년, 월, 일을 yyyyMMdd형의 문자열 날짜로 만든다.
 ★ parameter 
    1. nYear  : 년도 ( 예 : 2012 )
    2. nMonth : 월 ( 예 : 11 )
    3. nDate   : 일 ( 예 : 22 )
 ★ return 
    - 성공 = yyyyMMdd형태의 날짜 ( 예 : "20121122" )
    - 실패 = ""
 ★ 주의사항     
    년, 월, 일의 값이 범위에 맞지 않는 값을 입력하면 그에 적합한 날짜로 변경해준다.
    (예 : nYear = 2012, nMonth = 13, nDate = 32 ==> return = "20130201"
          nYear = 2012, nMonth = 1, nDate = -1 ==> return = "20111230")
**********************************************************************************/
function MakeDate(nYear, nMonth, nDate)
{
	if( IsNull(nYear) || IsNull(nMonth) || IsNull(nDate) )	return "";
	
    var objDate = new Date(nYear, nMonth-1, nDate);

	var sYear   = objDate.getFullYear().toString();
	var sMonth  = Right("0" + (objDate.getMonth() + 1), 2);
	var sDate   = Right("0" + objDate.getDate(), 2);

	return sYear + sMonth + sDate;
}


/**********************************************************************************
 ★ 설명
    입력된 날자에 nOffset 으로 지정된 만큼의 일을 증감한다.
 ★ parameter 
    1. sDate : 날짜 ( 예 : "20121122" )
    2. nOffset : 일 증감값 ( 예 : 10 또는 -10 )
 ★ return 
    - 성공 = yyyyMMdd형태의 증감된 날짜 ( 예 : "20121202" 또는 "20121112" )
    - 실패 = ""
**********************************************************************************/
function AddDate(sDate, nOffset)
{
	if( IsNull(sDate) || IsNull(nOffset) )	return "";
	
    var nYear = parseInt(sDate.substr(0, 4));
    var nMonth = parseInt(sDate.substr(4, 2));
    var nDate = parseInt(sDate.substr(6, 2)) + nOffset;

    return MakeDate(nYear, nMonth, nDate);
}

/**********************************************************************************
 ★ 설명
    입력된 날자에 nOffset 으로 지정된 만큼의 월을 증감한다.
 ★ parameter 
    1. sDate : 날짜 ( 예 : "20121122" )
    2. nOffset : 월 증감값 ( 예 : 1 또는 -1 )
 ★ return 
    - 성공 = yyyyMMdd형태의 증감된 날짜 ( 예 : "20121202" 또는 "20121022" )
    - 실패 = ""
 ★ 주의사항    
    단, 증감된 날짜가 그달의 마지막날짜월보다 큰 경우는 드달의 마지막 날짜를 return한다.
    예를 들어, sDate="20120531", nOffset=-1일 경우 return="20120430" 이 된다.
**********************************************************************************/
function AddMonth(sDate, nOffset)
{
	if( IsNull(sDate) || IsNull(nOffset) )		return "";
	sDate = getTrim(sDate);
	
    var nYear 	= parseInt(sDate.substr(0, 4));
    var nMonth 	= parseInt(sDate.substr(4, 2))+nOffset;
    var nDate 	= parseInt(sDate.substr(6, 2));    
    
	var nLastDate, sRet;

	// 날짜를 가져온데이터
	sRet = MakeDate(nYear, nMonth, nDate);
	
    var nsYear 	= parseInt(sRet.substr(0, 4));
    var nsMonth = parseInt(sRet.substr(4, 2));
    var nsDate 	= parseInt(sRet.substr(6, 2)); 	
	
    nLastDate = LastDateNum(sRet);    
    
    sRet = sRet.substr(0,6);
    
    if( nsDate > nLastDate ){
		sRet += nLastDate.toString();
	}else{
		sRet += (Right("0" + nsDate, 2)).toString();
	}	
	return sRet;
}

/*******************************************************************************
 ★ 설명
    해당 PC의 오늘 날짜를 가져온다.
 ★ parameter 
 ★ return 
    - 성공 = yyyyMMdd형태의 오늘 날짜 ( 예 : "20121122" )
    - 실패 = 없음
******************************************************************************/ 
function Today()
{
	var sToday = "";
	var objDate = new Date();
	var sToday  = objDate.getFullYear().toString();
	sToday += Right("0" + (objDate.getMonth() + 1), 2);
	sToday += Right("0" + objDate.getDate(), 2);

	return sToday;
}	

/*******************************************************************************
 ★ 설명
    해당 PC의 오늘 날짜 + 시간을 가져온다.
 ★ parameter 
 ★ return 
    - 성공 = yyyyMMddhhmiss형태의 오늘 날짜 ( 예 : "20121122223010" )
    - 실패 = 없음
******************************************************************************/ 
function TodayTime()
{
	var strToday = "";
	var objDate = new Date();
	var sToday  = objDate.getFullYear().toString();
	sToday += Right("0" + (objDate.getMonth() + 1), 2);
	sToday += Right("0" + objDate.getDate(), 2);
	sToday += Right("0" + objDate.getHours(), 2);
	sToday += Right("0" + objDate.getMinutes(), 2);
	sToday += Right("0" + objDate.getSeconds(), 2);
	//strToday += objDate.getMilliseconds();
	return sToday;
}	

/*******************************************************************************
 ★ 설명
    두 일자간의 차이 일수 계산
 ★ parameter 
    1. sStartDate : yyyyMMdd형태의 From 일자 ( 예 : "20121122" )
    2. sEndDate   : yyyyMMdd형태의 To 일자 ( 예 : "20121202" )
 ★ return 
    - 성공 = 숫자 형태의 차이일수  ( 예 : 10 ) 
             단, sEndDate < sStartDate이면 음수가 return된다. 
    - 실패 = NaN
 ******************************************************************************/
function DiffDate(sStartDate, sEndDate)
{
	if( IsNull(sStartDate) || IsNull(sEndDate) )		return NaN;
	
    var vFromDate = new Date(parseInt(sEndDate.substring(0,4),  10), parseInt(sEndDate.substring(4,6)-1,  10), parseInt(sEndDate.substring(6,8), 10));
    var vToDate = new Date(parseInt(sStartDate.substring(0,4),  10), parseInt(sStartDate.substring(4,6)-1,  10), parseInt(sStartDate.substring(6,8), 10));
    
    return parseInt((vFromDate - vToDate)/(1000*60*60*24));
}

/*******************************************************************************
 ★ 설명
    두 월간의 차이 월수 계산 
 ★ parameter 
    1. sStartDate : yyyyMMdd형태의 From 일자 ( 예 : "20121122" )
    2. sEndDate   : yyyyMMdd형태의 To 일자 ( 예 : "20131202" )
 ★ return 
    - 성공 = 숫자 형태의 차이월수  ( 예 : 10 )
             단, sEndDate < sStartDate이면 음수가 return된다. 
    - 실패 = NaN
 ★ 주의사항     
    단, sStartDate, sEndDate의 일은 포함하지 않고 계산된다.
**********************************************************************************/
function DiffMonth(sStartDate, sEndDate)
{
	var nStartMon, nEndMon;
	
	if( IsNull(sStartDate) || IsNull(sEndDate) )	return NaN;
	
	nStartMon = parseInt(sStartDate.substr(0,4), 10)*12 + parseInt(sStartDate.substr(4,2), 10);
	nEndMon = parseInt(sEndDate.substr(0,4), 10)*12 + parseInt(sEndDate.substr(4,2), 10);
	
	return (nEndMon - nStartMon);
}

/*******************************************************************************
 ★ 설명
    Date기본 Format( = yyyyMMdd[hhmiss])를 
    XP Date기본 Format( = yyyy-MM-dd[ hh:mi:ss] ) 으로 바꾸어줌
 ★ parameter 
    1. sDate : yyyyMMdd[hhmiss]형태의 일자 ( 예 : "20121122" 또는 "20121122010203")
 ★ return 
    - 성공 = XP Date기본 Format( 예 : "2012-11-22" 또는 "2012-11-22 01:02:03")
    - 실패 = ""
 ★ 주의사항
    sDate는 yyyyMMdd 또는 yyyyMMddhhmiss 형태만 처리된다.
**********************************************************************************/
function Date2XP(sDate)
{
	var ret;
	
	if( IsNull(sDate) )		return "";
	
	if( sDate.length != 8 && sDate.length != 14 )
		return "";
	ret = sDate.substr(0, 4) + "-" + sDate.substr(4, 2)+ "-" + sDate.substr(6, 2);
	if( sDate.length > 8 )
		ret += " " + sDate.substr(8,2) + ":" + sDate.substr(10,2) + ":" + sDate.substr(12,2);
	
	return ret;
}

/*******************************************************************************
 ★ 설명
    요일구하기
 ★ parameter 
    sDate : yyyyMMdd형태의 날짜 ( 예 : "20121122" )
 ★ return 
    - 성공 = 요일(0=일요일, ~ , 6=토요일)
    - 실패 = -1
 ★ 목적
    XPlatofrm거는 쓰기가 불편해서 만들었음
******************************************************************************/  
function GetDay(sDate)
{
	if( IsNull(sDate) )		return -1;
	
	var oDate = new Date(Date2XP(sDate));
	return oDate.getDay();	
}

////////////////////////////////////////////////////////////////////////////////
// Date End
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Form & Component Start
////////////////////////////////////////////////////////////////////////////////
/*******************************************************************************
 ★ 설명
     Modal Dialog실행 함수
 ★ parameter 
    _NewChildFrame()참조
 ★ return 
    - 성공 = variant ( Dialog창에서 close()에 의해 Return된 값 )
    - 실패 = ""
 ******************************************************************************/
function Dialog(sID, sURL, sArg, nLeft, nTop, nWidth, nHeight, sStyle, sProp)
{
	var rtn=null;
	var newChild;
	var MyFrame = this.getOwnerFrame();	
	
	newChild = _NewChildFrame(sID, sURL, sArg, nLeft, nTop, nWidth, nHeight, sStyle, sProp);
	rtn = newChild.showModal(sID, MyFrame, sArg);
	this.removeChild(newChild.name);
	newChild.destroy();
	newChild = null;

	if( IsNull(rtn) )	rtn = "";
	
	return rtn;
}

/*******************************************************************************
 ★ 설명
     Modaless Dialog실행 함수
 ★ parameter 
    _NewChildFrame()참조
 ★ return 
    - 성공 = true ( 정상작동여부 )
    - 실패 = false
 ******************************************************************************/
function Open(sID, sURL, sArg, nLeft, nTop, nWidth, nHeight, sStyle, sProp)
{
	var rtn;
	var newChild;
	var MyFrame = this.getOwnerFrame();
		
	newChild = _NewChildFrame(sID, sURL, sArg, nLeft, nTop, nWidth, nHeight, sStyle, sProp);
	
	return newChild.showModeless(sID, MyFrame, sArg);	
}

/*******************************************************************************
 ★ 설명
     Object의 Property를  설정한한다.
 ★ parameter 
    1. sObjName = Object Name ( 예 : Button00, ... )
    2. sPropName = Property Name ( 예 : enable, style.border, ... )
    3. sPropVal - Property Value ( 예 : true, "1 solid blue", ... )
 ★ return 
    - 성공 = 수행된 Property Setting 문자열 ( TEST를 위해 Return함 )
    - 실패 = ""
 ******************************************************************************/
function SetProp(sObjName, sPropName, sPropVal)
{
	if( IsNull(sObjName) || IsNull(sPropName) || IsNull(sPropVal) )		return "";
	
	var sPropExpr = sObjName+"."+sPropName+" = " + sPropVal;
	eval(sPropExpr);
	
	return sPropExpr;
}

/*******************************************************************************
 ★ 설명
     Object의 Property를  가져온다.
 ★ parameter 
    1. sObjName = Object Name ( 예 : Button00, ... )
    2. sPropName = Property Name ( 예 : enable, style.border, ... )
 ★ return 
    - 성공 = Property 값
    - 실패 = eval()과 동일
 ******************************************************************************/
function GetProp(sObjName, sPropName, sPropVal)
{
	var sPropExpr = sObjName+"."+sPropName;
	return eval(sPropExpr);
}

/*******************************************************************************
 ★ 설명
     Object의 type을 문자열로 얻어온다.
 ★ parameter 
    1. oObj : type을 얻어올 Object
			  (예 : mainframe, this.getOwnerFrame(), this, button,...)
 ★ return 
    - 성공 = Object의 type문자열(예 : "MainFrame", "ChildFrame", "Form", "Button",...) 
    - 실패 = ""
 ******************************************************************************/
function GetObjType(oObj)
{
	var sType;
	
	if( IsNull(oObj) )		return "";
	
	sType = oObj.toString().valueOf().substr(1,6);
	if( sType.toLowerCase() == "object" )
		return Mid(oObj.toString().valueOf(), " ", "]");

	return "";
}

/*******************************************************************************
 ★ 설명
     모든 Collection이 type을 이용하여 얻어오는 것이 없으므로 type을 이용하여
     Collection을 얻어오는 함수임
     단, type은 Object에 의해 나오는 Value값을 의미한다.
     예를들어, alert(Button0)="[object Button]" 에서 "Button"을 Type이라 한다.
 ★ parameter 
    1. oCollection : Collection Object(예 : this.components, mainframe.all, ...)
    2. sType       : Type문자열 (예 : "ChildFrame", "Button")
					 (옵션: Default="" ==> return은 oCollection이 된다.)
 ★ return 
    - 성공 = Collection List중 sType에 적합한 Object만 Array로 Return한다.
    - 실패 = 
 ******************************************************************************/
function GetObjTypeCollection(oCollection, sType)
{
	var sType, i, arr=new Array(), arr_no=0, sColType;
	
	if( IsNull(oCollection) )		return arr;
	if( IsNull(sType) )			
	{
		arr = oCollection;
		return arr;
	}
	for( i = 0 ; i < oCollection.length ; i++ )
	{
		sColType = GetObjType(oCollection[i]);
		if( IsNull(sColType) )	continue;
		if( sType.toLowerCase() == sColType.toLowerCase() )
		{
			arr[arr_no] = oCollection[i];
			arr_no++;
		}
	}

	return arr;
}

/*******************************************************************************
 ★ 설명
     sObjName이 Popup창(showModaless()에 의해 뜬창)인지 확인한다.
     단, showModal()에 의해 뜬 창은 해당되지 않는다.
 ★ parameter 
    1. sObjName : Popup창 여부를 확인할 Object Name
 ★ return 
    - sObjName이 Popup창인 경우 = true
    - sObjName이 Popup창이 아닌 경우 = false
 ★ 주의사항
    단, showModal()에 의해 뜬 창은 해당되지 않는다. 
 ******************************************************************************/
function IsObjPopup(sPopupName)
{
	if( IsNull(sPopupName) )	return false;
	
	if( IsNull(application.popupframes(sPopupName)) )
		return false;
	else
		return true;
}

/*******************************************************************************
 ★ 설명
     Object를 생성한다. 만일 Object가 이미 존재하면 존재하는 Object를 return한다.
     (예 : sObjType="Button", sObjName="Button00"이면 
           Button00 Object를 생성하여 oParent에 포함시킨 후 Return한다.)
 ★ parameter 
    1. sObjName : 생성할 Object Name ( 예 : "Button00" )
    2. sObjType : 생성할 Object Type ( 예 : "Button", "Static", ... )
    3. oParent  : 포함시킬 부모 Object(옵션 : Default=this) (예 : this, childframe, ... )
    4. bShow    : 화면에 보여질지 여부 (옵션 : Default=true)
 ★ return 
    - 성공 = 생성된 Object 또는 이미 존재하면 해당 Object
    - 실패 = null
 ★ 주의사항
    - Component생성만 할것, 다른 Object는 Test안해봐서 신뢰할 수 없음
 ******************************************************************************/
function NewObj(sObjName, sObjType, oParent, bShow)
{
	var sFstr, oRet, aObjExist;

	if( IsNull(sObjName) )	return null;
	if( IsNull(sObjType) ) 	return null;
	
	if( IsNull(oParent) )	oParent = this;	
	if( IsNull(bShow) ) 	bShow = true;
	
	aObjExist = oParent.all(sObjName);
	if( aObjExist != null )
		return aObjExist;
	
	sFstr = "new " + sObjType + "(\"" + sObjName + "\")";
	oRet = eval(sFstr);
	if( IsNull(oRet) )
		return null;
		
	if( oParent.addChild(sObjName, oRet) == -1 )
		return null;

	if( bShow == true )
		oRet.show();
	
	return oRet;
}

/*******************************************************************************
 ★ 설명
     Object를 생성한다. 만일 Object가 이미 존재하면 존재하는 Object를 return한다.
     (예 : sObjType="Button", sObjName="Button00"이면 
           Button00 Object를 생성하여 oParent에 포함시킨 후 Return한다.)
 ★ parameter 
    1. sObjName : 생성할 Object Name ( 예 : "Button00" )
    2. sObjType : 생성할 Object Type ( 예 : "Button", "Static", ... )
    3. oParent  : 포함시킬 부모 Object(옵션 : Default=this) (예 : this, childframe, ... )
    4. bShow    : 화면에 보여질지 여부 (옵션 : Default=true)
 ★ return 
    - 성공 = 생성된 Object 또는 이미 존재하면 해당 Object
    - 실패 = null
 ★ 주의사항
    - Component파괴만 할것, 다른 Object는 Test안해봐서 신뢰할 수 없음
 ******************************************************************************/
function DelObj(sObjName, oParent)
{
	var oObj;
	
	if( IsNull(sObjName) )	return false;
	
	if( IsNull(oParent) )	
		oParent = this;
	
	oObj = oParent.all(sObjName);	
	if( oObj == null )	return true;
	
	oParent.removeChild(sObjName); 	
	
	oObj.destroy();
	oObj = null;

	return true;
}

/*******************************************************************************
 ★ 설명
    oObj에 해당하는 좌표계가 Screen좌표계인지를 체크한다.
 ★ parameter 
    1. oObj : 체크할 Object(예 : mainframe, this.getOwnerFrame(), this, button,...)
  ★ return 
    - oObj가 Screenr기준 좌표계인 경우 = true
    - oObj가 Screenr기준 좌표계가 아닌경우 = false
    - oObj가 null인 경우 = false    
 ******************************************************************************/
function IsObjScreenPos(oObj)
{
	var sType;
	
	if( IsNull(oObj) )		return false;
	
	sType = GetObjType(oObj);
	if( IsNull(sType) ) 	return false;

	if( sType.toLowerCase() == "mainframe" )
		return true;
	if( sType.toLowerCase() == "childframe" )
	{
		if( IsObjPopup(oObj.name) == true )
			return true;
	}
		
	return false;
}

/*******************************************************************************
 ★ 설명
    oObj에 해당하는 Object가 Position을 갖지 않는 Object인지 판단한다.
    즉, oObj가 invisible Object인지 판단한다.
 ★ parameter 
    1. oObj : 체크할 Object(예 : application, mainframe, this.getOwnerFrame(), this, button,...)
 ★ return 
    - oObj가 position property가 없는 경우 = true
    - oObj가 position property가 있는 경우 = false
    - oObj가 null인 경우 = false
 ******************************************************************************/
function IsObjNoPos(oObj)
{
	var sType;
	
	if( IsNull(oObj) )		return false;
	
	sType = GetObjType(oObj);
	if( IsNull(sType) ) 	return false;

	if( IsNull(oObj.position) )
		return true;
		
	return false;
}

/*******************************************************************************
 ★ 설명
     system의 cursorx, cursory를 해당 Object의 영역좌표에 맞는 값으로 변경한다.
 ★ parameter 
    1. oObj : Object 
       (예 : mainframe, this.getOwnerFrame(), this, button,...)
 ★ return 
    - 성공 = oObj좌표계에 해당하는 Cursor position 문자열 ( 예 : "20 20" ) 
    - 실패 = ""
 ★ 주의사항    
    단, event에서 얻어지는 cursor좌표는 아니다. 
 ******************************************************************************/
function GetObjCursorPos(oObj)
{
	var sObjPos;
	var cursorx, cursory;
	var sCursorPos;

	if( IsNull(oObj) ) 	return "";
	if( IsObjNoPos(oObj) ) 	return "";
	
	cursorx = system.cursorx;
	cursory = system.cursory;
	
	if( IsObjScreenPos(oObj) == true )
		sCursorPos = cursorx + " " + cursory;
	else
		sCursorPos = (system.screenToClientX(oObj, cursorx)+oObj.position.left) + " " +	(system.screenToClientY(oObj, cursory)+oObj.position.top);		

	return sCursorPos;
}

/*******************************************************************************
 ★ 설명
    Position문자열을 Rect Object로 바꾼다.
 ★ parameter 
    1. sPos : Position 문자열 (예 : "10 10 50 50" 또는 "10 10")
 ★ return 
    1. 성공 = Rect Object
              (※ 단,  sPos = "10 10" ==> 2개인 경우
                  Rect.right = Rect.left, Rect.bottom = Rect.top,
                  Rect.width = 0, Rect.height = 0)
    2. 실패 = null
 ★ 주의사항
    1. Rect Object는 좌표를 처리하는 XPlatform 내부 Object로서 메뉴얼에는 존재치 않는다.
       Rect Object의 멤버는 left, top, right, bottom, width, height가 있다.
       (예 : rect가 Rect Object라면 rect.left, rect.top으로 사용하면 된다.)
    2. Rect Object내에서의 좌표 처리 방법 ( 
       1) right ==> width순으로 처리하면 right는 재계산된다.
          width ==> right순으로 처리하면 right는 재계산 되지 않는다.
       2) width처리를 하지 않고 right만 처리하면 width는 자동계산 된다.
          right처리를 하지 않고 width만 처리하면 right는 자동계산 된다.
       3) 위 1), 2)는 left를 먼저 지정했을 경우에 한하여 처리된다.
          또한, top, bottom에 대해서도 동일하게 처리된다.
******************************************************************************/ 
function Str2Rect(sPos)
{
	var oRect = new Rect();
	var i;
	var aPos, no;
	
	if( IsNull(sPos) )	return null;
	
	aPos = sPos.toString().split(" ");;
	if( aPos.length == 0 )
		return null;
		
	no = 0;
	for( i = 0 ; i < aPos.length ; i++ )
	{
		if( IsNum(aPos[i]) == true )
		{
			if( no == 0 )		oRect.left = Math.round(parseFloat(aPos[i]),1);
			if( no == 1 )		oRect.top = Math.round(parseFloat(aPos[i]),1);
			if( no == 2 )		oRect.right = Math.round(parseFloat(aPos[i]),1);
			if( no == 3 )		oRect.bottom = Math.round(parseFloat(aPos[i]),1);
			if( no == 4 )		oRect.width = Math.round(parseFloat(aPos[i]),1);
			if( no == 5 )		oRect.height = Math.round(parseFloat(aPos[i]),1);
			no++;
		}
	}

	if( no != 2 && no != 4 && no != 6 )
		return null;
		
	if( no == 2 )
	{
		oRect.right = oRect.left;
		oRect.bottom = oRect.top;
		oRect.width = 0;
		oRect.height = 0;
	}
	
	return oRect;
}

/*******************************************************************************
 ★ 설명
    Rect Object를 Position문자열로 바꾼다.
 ★ parameter 
    1. oRect : Rect Object(예 : Rect.left = 10, ... )
 ★ return 
    1. 성공 = Position문자열 ( 예 : "10 20 30 40" )
              (※ 단,  
                  Rect.right = Rect.left, Rect.right = Rect.left, 
                  Rect.width = 0, Rect.height = 0 인경우는
                  return = "10 10")
    2. 실패 = ""
 *****************************************************************************/ 
function Rect2Str(oRect)
{
	if( IsNull(oRect) )		return "";
	
	if( IsPoint(oRect) == true )
		return oRect.left + " " + oRect.top;
	else
		return oRect.left + " " + oRect.top + " " + oRect.right + " " + oRect.bottom;
}

/*******************************************************************************
 ★ 설명
    Rect Object의 내용이 Point(left, top만  유효한 경우)인지 판단한다.
 ★ parameter 
    1. oRect : Rect Object(예 : Rect.left = 10, ... )
 ★ return 
    1. 성공 = true (Point인 경우)
    2. 실패 = false ( oRect가 null이거나 Point가 아닌 경우)
 *****************************************************************************/ 
function IsPoint(oRect)
{
	if( IsNull(oRect) )		return false;
	
	if( (oRect.left == oRect.right && oRect.top == oRect.bottom) ||
		(oRect.width == 0 && oRect.height == 0 ) ||
		( (oRect.left != 0 && oRect.right == 0) && (oRect.top != 0 && oRect.bottom == 0) ) )
		return true;
	else
		return false;
}

/*******************************************************************************
 ★ 설명
     sAreaPos의 Center위치에 맞는 sObjPos의 position을 구한다.
 ★ parameter 
    1. sAreaPos : 영역에 해당하는 Position 문자열
				(예 : "10 10 50 50", this.position,...)
    2. sObjPos  : Center에 위치할 대상 Object의 Position
                  (옵션 : Default="" ==> Object의 Width=0, Height=0인 경우에 해당함)
				(예 : "", "10 10 30 30", this.position,...)
 ★ return 
    - 성공 = sAreaPos의 좌표계에 해당하는 Center position 문자열 
              ( 예 : sObjPos=""인 경우 ==> "30 30", 
                     sObjPos="10 10 20 20"인 경우 ==> "20 20 40 40" )
    - 실패 = ""                     
 ******************************************************************************/
function GetCenterPos(sAreaPos, sObjPos)
{
	var vAreaPos;
	var vObjPos  = new Rect();
	var vCenterPos = new Rect();

	if( IsNull(sAreaPos) )	return "";
	vAreaPos = Str2Rect(sAreaPos);
	if( IsNull(vAreaPos) )		return "";

	if( IsNull(sObjPos) )	
	{
		vObjPos.left = vObjPos.right = 0;
		vObjPos.top = vObjPos.bottom = 0;
		vObjPos.width = 0;
		vObjPos.height = 0;
	}
	else
	{
		vObjPos = Str2Rect(sObjPos);
		if( IsNull(vObjPos) )		return "";
	}

	if( IsPoint(vObjPos) == true )
	{
		vCenterPos.left = vAreaPos.left + Math.round(vAreaPos.width/2,1);
		vCenterPos.top = vAreaPos.top + Math.round(vAreaPos.height/2,1);
	}
	else
	{
		vCenterPos.left = vAreaPos.left + Math.round(vAreaPos.width/2,1) - Math.round(vObjPos.width/2,1);
		vCenterPos.top = vAreaPos.top + Math.round(vAreaPos.height/2,1) - Math.round(vObjPos.height/2,1);
		vCenterPos.right = vCenterPos.left + vObjPos.width;
		vCenterPos.bottom = vCenterPos.top + vObjPos.height;
	}

	return Rect2Str(vCenterPos);
}

/*******************************************************************************
 ★ 설명
     nLeft, nTop좌표로
     sPosition의 Width에 대해 n Offset Width만큼, 
     sPosition의 Height에 대해 n Offset Height만큼 
     이동한 좌표 Position문자열을 획득한다.
 ★ parameter 
    1. sPosition     : position 문자열 (예 : "absolute 10 10 20 20" = object.position ) 
                       단, "absolute"는 생략 가능하다.
    2. nLeft         : 이동할 Left 값 ( 예 : 10 또는 -10 )
    3. nTop          : 이동할 Top 값 ( 예 : 10 또는 -10 )
    4. nOffsetWidth  : 이동할 Offset Width값 ( 예 : 10 또는 -10 )
						(옵션 : Default = 0, 즉 이동하지 않는다) 
    5. nOffsetHeight : 이동할 Offset Height값 ( 예 : 10 또는 -10 )
						(옵션 : Default = 0, 즉 이동하지 않는다) 
 ★ return 
    - 성공 = 이동될 Position문자열 ( 예 : "absolute 20 20 30 30" 또는 "absolute 0 0 10 10" )
              단, sPosition이 2개만 지정된 경우 offsetWidth, nOffsetHeight에 어떤값을 지정하면
              이 경우는 Widht=0, Height=0와 동일하므로 4개로 바꾸어 Return한다.
              ( 예 : GetMovePos("10 10", 20, 20) = "20 20 20 20" )
    - 실패 = "" 
 ★ 목적
    XPlatform은 Width, Height가 아닌 Right, Bottom을 적용하기 때문에 헷갈리는 면이 있다.
    또한, object를 이동시키는 함수는 있지만 이동될 좌표만 구하는 함수가 없기 때문에
    이 함수를 만들었다.
 ******************************************************************************/
function GetMovePos(sPosition, nLeft, nTop, nOffsetWidth, nOffsetHeight)
{
	var sType;
	var vPosition;
	var vRetPosition = new Rect();

	if( IsNull(sPosition) || IsNull(nLeft) || IsNull(nTop) )	return "";
	
	if( IsNull(nOffsetWidth) )			
		nOffsetWidth = 0;
	if( IsNull(nOffsetHeight) )			
		nOffsetHeight = 0;

	vPosition = Str2Rect(sPosition);
	if( IsNull(vPosition) )		return "";

	vRetPosition.left = nLeft;
	vRetPosition.top = nTop;
	if( IsPoint(vPosition) == true ) 
	{
		if( nOffsetWidth == 0 && nOffsetHeight == 0 ) 
			return Rect2Str(vRetPosition);
		else
		{
			vPosition.width = 0;
			vPosition.height = 0;
		}
	}

	vRetPosition.right = vRetPosition.left + (vPosition.width + nOffsetWidth);
	vRetPosition.bottom = vRetPosition.top + (vPosition.height + nOffsetHeight);

	return Rect2Str(vRetPosition);
}

/*******************************************************************************
 ★ 설명
     sPosition대비 
     Left좌표에 대해 nOffsetLeft만큼, Top좌표에 대해 nOffsetTop만큼,
     Width에 대해 n Offset Width만큼, Height에 대해 n Offset Height만큼 
     이동한 좌표 Position문자열을 획득한다.
 ★ parameter 
    1. sPosition     : position 문자열 (예 : "absolute 10 10 20 20" = object.position ) 
                       단, "absolute"는 생략 가능하다.
    2. nOffsetLeft   : sPosition대비 이동할 Left Offset값 ( 예 : 10 또는 -10 )
    3. nOffsetTop    : sPosition대비 이동할 Left Offset값 ( 예 : 10 또는 -10 )
    4. nOffsetWidth  : sPosition대비 이동할 Width Offset 값 ( 예 : 10 또는 -10 )
						(옵션 : Default = 0, 즉 이동하지 않는다) 
    5. nOffsetHeight : sPosition대비 이동할 Height Offset 값 ( 예 : 10 또는 -10 )
						(옵션 : Default = 0, 즉 이동하지 않는다) 
 ★ return 
    - 성공 = 이동될 Position문자열 ( 예 : "absolute 20 20 30 30" 또는 "absolute 0 0 10 10" )
              단, sPosition이 2개만 지정된 경우 offsetWidth, nOffsetHeight에 어떤값을 지정하면
              이 경우는 Widht=0, Height=0와 동일하므로 4개로 바꾸어 Return한다.
              ( 예 : GetMovePos("10 10", 20, 20) = "20 20 20 20" )
    - 실패 = "" 
 ******************************************************************************/
function GetMoveToPos(sPosition, nOffsetLeft, nOffsetTop, nOffsetWidth, nOffsetHeight)
{
	var nLeft, nTop;
	var vPosition;	
	
	if( IsNull(sPosition) || IsNull(nOffsetLeft) || IsNull(nOffsetTop) )	return "";
	
	if( IsNull(nOffsetWidth) )
		nOffsetWidth = 0;
	if( IsNull(nOffsetHeight) )
		nOffsetHeight = 0;

	vPosition = Str2Rect(sPosition);
	if( IsNull(vPosition) )		return "";

	nLeft = vPosition.left + nOffsetLeft;
	nTop = vPosition.top + nOffsetTop;	

	return GetMovePos(sPosition, nLeft, nTop, nOffsetWidth, nOffsetHeight);
}

/*******************************************************************************
 ★ 설명
    oObj에 해당하는 Object의 border width를 구하는 함수이다.
 ★ parameter 
    1. oObj : Object 
       (예 : mainframe, this.getOwnerFrame(), this, button,...)
 ★ return 
    - 성공 = oObj의 Border Width
    - 실패 = -1    
 ★ 목적    
    현재 XPlatform(2009.12.10.1)에서 border가 지정되지 않고 style로 적용되어 있으면
    border를 구하지 못하므로 만들었다.

 ******************************************************************************/
function GetObjBorderWidth(oObj)
{
	if( IsNull(oObj) )	return -1;
	if( IsObjNoPos(oObj) ) 	return -1;

	if( IsNull(oObj.style.border.width) || IsNull(oObj.style.border.width) )
	{
		var sType;	
		
		sType = GetObjType(oObj);
		if( IsObjScreenPos(oObj) == true )
			return 0-system.screenToClientX(oObj, oObj.position.left);
		else
		{
			if( GetObjType(oObj.parent).toLowerCase() == "form" )
				return 0;
			else
				return system.clientToScreenX(oObj, 0) - system.clientToScreenX(oObj, oObj.position.left);
		}
	}
	else
		return oObj.style.border.width;
}


/*******************************************************************************
 ★ 설명
     oFromObj 좌표계의 sFromObjPos에 해당하는 Position을
     oToObj 좌표계에 해당하는 Position으로 바꾼다.
 ★ parameter 
	1. sFromPos : 변경하고자 하는 oFromAreaObj좌표계 내에서의 Position
	            (예 : "10 10" 또는 "10 10 20 20", Button.position, ...)
    2. oFromAreaObj : 변경할 좌표계 Object,
                  단, Screen의 경우는 "screen"을 넣으면 된다.
				(예 : "screen", mainframe, this,...)
    3. oToAreaObj  : 변경할 좌표계 Object
                 단, Screen의 경우는 "screen"을 넣으면 된다. 
				(예 : "screen", mainframe, this,...)
 ★ return 
    - 성공 = oToObj 좌표계로 변경된  position 문자열 
    - 실패 = ""
 ★ 목적
	ScreenToClient, ClientToScreen 밖에 없고 A Object에서 B Object좌표계로
	한번에 변경하는 함수가 없어서 만들었음 

 ******************************************************************************/
function GetObjConvPos(sFromPos, oFromAreaObj, oToAreaObj)
{
	var vFromPos;
	var vRetPos = new Rect();

	if( IsNull(sFromPos) || IsNull(oFromAreaObj) || IsNull(oToAreaObj) )		return "";
	if( IsObjNoPos(oFromAreaObj) ) 	return "";	
	if( IsObjNoPos(oToAreaObj) ) 	return "";		
	
	if( oFromAreaObj == oToAreaObj )
		return sFromPos;
	vFromPos = Str2Rect(sFromPos);
	if( IsNull(vFromPos) )		return "";
	
	if( oFromAreaObj.toString().toLowerCase() == "screen" )
	{
		vRetPos.left = system.screenToClientX( oToAreaObj, vFromPos.left );
		vRetPos.top = system.screenToClientY( oToAreaObj, vFromPos.top );
	}
	else if( oToAreaObj.toString().toLowerCase() == "screen" )
	{
		vRetPos.left = system.clientToScreenX( oFromAreaObj, vFromPos.left );
		vRetPos.top = system.clientToScreenY( oFromAreaObj, vFromPos.top );
	}
	else
	{
		vRetPos.left = system.clientToScreenX( oFromAreaObj, vFromPos.left );
		vRetPos.top = system.clientToScreenY( oFromAreaObj, vFromPos.top );
		vRetPos.left = system.screenToClientX( oToAreaObj, vRetPos.left );
		vRetPos.top = system.screenToClientY( oToAreaObj, vRetPos.top );
	}
	if( IsPoint(vFromPos) == false )
	{
		vRetPos.right = vRetPos.left + vFromPos.width;
		vRetPos.bottom = vRetPos.top + vFromPos.height;
	}
	return Rect2Str(vRetPos);	
}

/*******************************************************************************
 ★ 설명 
    sAreaPos좌표계 내에서 주어진 Align 조건에 따라 
    sObjPos의 좌표를 재 계산한다.
 ★ parameter 
    1. sAreaPos   : Object가 움직일 좌표영역에 해당하는 Position 문자열 ( 예 : "10 10 100 100" )
    2. sObjPos    : Align될 Object의 현재 Position문자열 ( 예 : "50 50 60 60" )
    3. sAxisPos   : 기준이 되는 X,Y축 Position문자열
					( 옵션 : Default=""==>sAreaPos의 center ) ( 예 : "60 60" )
    4. sOffsetPos : sAxisPos로부터의 Offset Position문자열 
                    ( 옵션 : Default="0 0" ) ( 예 : "10 10" 또는 "-10 -10" )
    5. nAlign     : sAxisPos를 기준으로 한 정렬형태 ( 옵션 : Default=0 )
                    0 = 중앙정렬, 1 = 1사분면, 2 = 2사분면, 3 = 3사분면, 4 = 4사분면
    6. bAuto      : nAlign을 기준으로 sObjPos의 Width, Height가 들어갈 수 있는
                    사분면을 자동으로 찾아 정렬한다.( 옵션 : Default=true )
                    true = 자동정렬, false = 자동정렬 하지 않음
    7. bBigResize : Object의 width, height가 해당 4분면의 영역보다 크면 4분면에 맞추어 
                    Object의 width, height를 줄여서 조정한다. 
                    즉, obj > Area이면 obj를 Area의 사분면에 맞춰 줄인다. ( 옵션 : Default = false )
                    true = Size 조정, false = Size 조정하지 않음
    8. bSmallResize : Object의 width, height가 해당 4분면의 영역보다 작으면 4분면에 맞추어 
                    Object의 width, height를 늘려서 조정한다. 
                    즉, obj < Area이면 obj를 Area의 사분면에 맞춰 늘인다. ( 옵션 : Default = false )
                    true = Size 조정, false = Size 조정하지 않음
 ★ return 
    - 성공 = 주어진 조건에 맞는 정렬된 Object의 Position문자열
    - 실패 = ""
 ★ 주의사항
    1. bAuto와 (bBigResize, bSmallResize)는 동시에 true일 수 없다.
       bAuto가 true이면 bBigResize, bSmallResize는 false로 처리된다.
    2. (sAxisPos+sOffsetPos)가 sAreaPos의 범위를 벗어나면 null이 return된다.
       단, sObjPos의 최종 Align된 Position은 sAreaPos의 범위를 벗어날 수도 있다.
    2. 모든 Position은 sAreaPos의 좌표계에 맞도록 전달되어야 한다.
       따라서, 머리가 아프다면 모든 좌표를 screen좌표로 처리한다면 
       좀 더 쉬워지겠지...
 ******************************************************************************/
function GetAlignPos( sAreaPos, sObjPos, sAxisPos, sOffsetPos, nAlign, bAuto, bBigResize, bSmallResize )
{
	var vAreaPos;
	var vAxisPos = new Rect();
	var vObjPos;
	var vOffsetPos;
	var vAlignPos = new Rect();

	if( IsNull(sAreaPos) || IsNull(sObjPos) )	return "";
	
	if( IsNull(sAxisPos) )
		sAxisPos = "";
	if( IsNull(sOffsetPos) )
		sOffsetPos = "0 0";
	if( IsNull(nAlign) )
		nAlign = 0;
	if( IsNull(bAuto) )
		bAuto = false;
	if( IsNull(bBigResize) )
		bBigResize = false;
	if( IsNull(bSmallResize) )
		bSmallResize = false;
		
	vAreaPos = Str2Rect(sAreaPos);
	if( IsNull(vAreaPos) )	return "";
	vObjPos = Str2Rect(sObjPos);	
	if( IsNull(vObjPos) )	return "";
	if( sAxisPos != "" )
	{
		vAxisPos = Str2Rect(sAxisPos);
		if( IsNull(vAxisPos) )	return null;
	}
	else
	{
		vAxisPos.left = vAreaPos.left + Math.round(vAreaPos.width/2,1);
		vAxisPos.top = vAreaPos.top + Math.round(vAreaPos.height/2,1);
	}

	vOffsetPos = Str2Rect(sOffsetPos);
	if( IsNull(vOffsetPos) )	return "";

	if( bAuto == true )
	{
		bBigResize = false;
		bSmallResize = false;
	}

	// Axis를 Offset만큼 보정
	vAxisPos.left += vOffsetPos.left;
	vAxisPos.top += vOffsetPos.top;
	
	// Axis가 Area의 범위를 벗어나면 return null
	if( vAxisPos.left < vAreaPos.left )
		return "";
	if( vAxisPos.left > vAreaPos.right ) 
		return "";
	if( vAxisPos.top < vAreaPos.top ) 
		return "";
	if( vAxisPos.top > vAreaPos.bottom ) 
		return "";
	
	// Center에 위치
	if( nAlign == 0 )
	{
		vAlignPos.left = vAxisPos.left - Math.round(vObjPos.width/2,1);
		vAlignPos.top = vAxisPos.top - Math.round(vObjPos.height/2,1);
	}
	// 1사분면에 위치
	else if( nAlign == 1 )
	{
		vAlignPos.left = vAxisPos.left;
		vAlignPos.top = vAxisPos.top - vObjPos.height;
	}
	// 2사분면에 위치	
	else if( nAlign == 2 )
	{
		vAlignPos.left = vAxisPos.left - vObjPos.width;
		vAlignPos.top = vAxisPos.top - vObjPos.height;
	}
	// 3사분면에 위치	
	else if( nAlign == 3 )
	{
		vAlignPos.left = vAxisPos.left - vObjPos.width;
		vAlignPos.top = vAxisPos.top;
	}
	// 4사분면에 위치
	else if( nAlign == 4 )
	{
		vAlignPos.left = vAxisPos.left;
		vAlignPos.top = vAxisPos.top;
	}
	
	vAlignPos.right = vAlignPos.left + vObjPos.width;
	vAlignPos.bottom = vAlignPos.top + vObjPos.height;

	// Auto처리
	if( bAuto == true )
	{
		var i;
		var aAlignPosAuto, sAlignPosAuto, nCurAlign;
		if( nAlign != 0 )
		{
			for( i = 0 ; i <= 4 ; i++ )
			{
				nCurAlign = (nAlign+i)%5;
				if( nCurAlign == 0 )	
					continue;
				sAlignPosAuto = GetAlignPos( sAreaPos, sObjPos, sAxisPos, sOffsetPos, 
												 nCurAlign, false, false, false );
				vAlignPosAuto = Str2Rect(sAlignPosAuto);
				if( (vAlignPosAuto.left >= vAreaPos.left) &&
					(vAlignPosAuto.right <= vAreaPos.right) &&
					(vAlignPosAuto.top >= vAreaPos.top) &&
					(vAlignPosAuto.bottom <= vAreaPos.bottom) )
				{
					vAlignPos = vAlignPosAuto;
					break;
				}
			}
		}
	}

	// Resize처리
	if( bBigResize == true || bSmallResize == true )
	{
		if( nAlign == 1 )
		{
			if( bBigResize == true )
			{
				if( vAlignPos.right > vAreaPos.right )		vAlignPos.right = vAreaPos.right;
				if( vAlignPos.top < vAreaPos.top )		vAlignPos.top = vAreaPos.top;						
			}
			if( bSmallResize == true )
			{
				if( vAlignPos.right < vAreaPos.right )		vAlignPos.right = vAreaPos.right;
				if( vAlignPos.top > vAreaPos.top )		vAlignPos.top = vAreaPos.top;						
			}
		}
		if( nAlign == 2 )
		{
			if( bBigResize == true )
			{
				if( vAlignPos.left < vAreaPos.left )		vAlignPos.left = vAreaPos.left;
				if( vAlignPos.top < vAreaPos.top )		vAlignPos.top = vAreaPos.top;						
			}
			if( bSmallResize == true )
			{
				if( vAlignPos.left > vAreaPos.left )		vAlignPos.left = vAreaPos.left;
				if( vAlignPos.top > vAreaPos.top )		vAlignPos.top = vAreaPos.top;						
			}
		}
		if( nAlign == 3 )
		{
			if( bBigResize == true )
			{
				if( vAlignPos.left < vAreaPos.left )		vAlignPos.left = vAreaPos.left;
				if( vAlignPos.bottom > vAreaPos.bottom )		vAlignPos.bottom = vAreaPos.bottom;						
			}
			if( bSmallResize == true )
			{
				if( vAlignPos.left > vAreaPos.left )		vAlignPos.left = vAreaPos.left;
				if( vAlignPos.bottom < vAreaPos.bottom )		vAlignPos.bottom = vAreaPos.bottom;						
			}
		}
		if( nAlign == 4 )
		{
			if( bBigResize == true )
			{
				if( vAlignPos.right > vAreaPos.right )		vAlignPos.right = vAreaPos.right;
				if( vAlignPos.bottom > vAreaPos.bottom )		vAlignPos.bottom = vAreaPos.bottom;						
			}
			if( bSmallResize == true )
			{
				if( vAlignPos.right < vAreaPos.right )		vAlignPos.right = vAreaPos.right;
				if( vAlignPos.bottom < vAreaPos.bottom )		vAlignPos.bottom = vAreaPos.bottom;						
			}
		}
		// Axis를 중심으로 작은 쪽에 맞추어 Resizing한다.
		if( nAlign == 0 )
		{
			var nSmallWidth, nSmallHeight;
			nSmallWidth = Math.min(vAxisPos.left - vAreaPos.left, vAreaPos.right - vAxisPos.left);
			nSmallHeight = Math.min(vAxisPos.top - vAreaPos.top, vAreaPos.bottom - vAxisPos.top);

			var bWFlag=false, bHFlag=false;		
			if( bSmallResize == true )
			{
				if( Math.round(vObjPos.width/2,1) < nSmallWidth )
					bWFlag = true;
				if( Math.round(vObjPos.height/2,1) < nSmallHeight )
					bHFlag = true;
			}
			if( bBigResize == true )
			{
				if( Math.round(vObjPos.width/2,1) > nSmallWidth )
					bWFlag = true;
				if( Math.round(vObjPos.height/2,1) > nSmallHeight )
					bHFlag = true;
			}
			if( bWFlag == true )
			{
				vAlignPos.left = vAxisPos.left - nSmallWidth;
				vAlignPos.right = vAxisPos.left + nSmallWidth;
			}
			if( bHFlag == true )
			{
				vAlignPos.top = vAxisPos.top - nSmallHeight;
				vAlignPos.bottom = vAxisPos.top + nSmallHeight;
			}
		}
	}

	vAlignPos.width = vAlignPos.right - vAlignPos.left;
	vAlignPos.height = vAlignPos.bottom - vAlignPos.top;

	return Rect2Str(vAlignPos);
}

/*******************************************************************************
 ★ 설명
    nX, nY좌표를 nCx, nCy를 중심으로 nAngle만큼 회전한 좌표를 구한다.
 ★ parameter 
    1. nX : 회전할 X좌표
    2. nY : 회전할 Y좌표
    3. nCx : 회전 중심 X좌표
    4. nCy : 회전 중심 Y좌표
    5. nAngle : 회전 각(※ radian, 숫자값이 아니다.)(예:Math.PI, Math.PI/2,...)
 ★ return 
    1. 성공 = Rect Object( 단, Rect.left = 회전된 X좌표, Rect.top = 화전된 Y좌표 )
    2. 실패 = null
******************************************************************************/ 
function RotatePoint(nX, nY, nCx, nCy, nAngle)
{
	var vPoint = new Rect();
	
	if( IsNull(nX) || IsNull(nY) || IsNull(nCx) || IsNull(nCy) || IsNull(nAngle) )
		return null;

	nY = -1*nY;
	nCy = -1*nCy;
	vPoint.left = nCx + Math.round(Math.cos(nAngle)*(nX-nCx) - Math.sin(nAngle)*(nY-nCy),1);
	vPoint.top = nCy + Math.round(Math.sin(nAngle)*(nX-nCx) + Math.cos(nAngle)*(nY-nCy),1);
	vPoint.top = -1*vPoint.top;

	return vPoint;
}

/*******************************************************************************
 ★ 설명
    A직선(Start ~ End)과 B직선(Start ~ End)의 교차점을 구한다.
 ★ parameter 
    1. nA_StartX : A직선의 Start X값
    2. nA_StartY : A직선의 Start Y값    
    3. nA_EndX   : A직선의 End X값
    4. nA_EndY   : A직선의 End Y값    
    5. nB_StartX : B직선의 Start X값
    6. nB_StartY : B직선의 Start Y값    
    7. nB_EndX   : B직선의 End X값
    8. nB_EndY   : B직선의 End Y값     
 ★ return 
    1. 성공 = Rect Object( 단, Rect.left = 교차점 X좌표, Rect.top = 교차점 Y좌표 )
    2. 실패 = null
 *****************************************************************************/ 
function CrossPoint(nA_StartX, nA_StartY, nA_EndX, nA_EndY,
				    nB_StartX, nB_StartY, nB_EndX, nB_EndY)	
{
	var vPoint = new Rect();
	var nA_Angle, nB_Angle;

	if( IsNull(nA_StartX) || IsNull(nA_StartY) || IsNull(nA_EndX) || IsNull(nA_EndY) || 
		IsNull(nB_StartX) || IsNull(nB_StartY) || IsNull(nB_EndX) || IsNull(nB_EndY) )
		return null;
			
	nA_StartY = -1*nA_StartY;
	nB_StartY = -1*nB_StartY;	
	nA_EndY = -1*nA_EndY;	
	nB_EndY = -1*nB_EndY;		
	nA_Angle = Math.tan(Math.atan2((nA_EndY - nA_StartY), (nA_EndX - nA_StartX)));
	nB_Angle = Math.tan(Math.atan2((nB_EndY - nB_StartY), (nB_EndX - nB_StartX)));	
	
	// 평행한 경우
	if( Math.abs(Deg2Rad(nA_Angle - nB_Angle))%180  == 0 )
		return null;
		
	vPoint.left = (nA_StartY - nB_StartY - nA_Angle*nA_StartX + nB_Angle*nB_StartX)/(nB_Angle - nA_Angle);
	vPoint.top = nA_StartY - nA_Angle*(nA_StartX - vPoint.left);
	
	vPoint.left = Math.round(vPoint.left,1);
	vPoint.top = -1*Math.round(vPoint.top,1);
	
	return vPoint;
}

///////////////////////////////////////////////////////////////////////////////
// Biz Validation Start
///////////////////////////////////////////////////////////////////////////////
/*******************************************************************************
 ★ 설명
    사업자 등록번호 확인
 ★ Parameter 
    1. sValue : 사업자 등록 번호
 ★ return 
    - sValue가 사업자등록번호 형식에 맞는 경우 = true
    - sValue가 사업자등록번호 형식에 맞지 않는 경우 = false
    - sValue가 없는 경우 = false
******************************************************************************/ 
function IsCompRegNo(sValue)
{
	if( IsNull(sValue) )	return false;
	
    var vCompNo = sValue.replace("-", "");
	var checkID = new Array(1, 3, 7, 1, 3, 7, 1, 3, 5, 1);
	var i, Sum=0, c2, remander;
	
	if (vCompNo.length != 10) 
		return false; 
	
	for (i = 0; i <= 7; i++) 
		Sum += checkID[i] * vCompNo.charAt(i);

	c2 = "0" + (checkID[8] * vCompNo.charAt(8));
	c2 = c2.substring(c2.length - 2, c2.length);

	Sum += Math.floor(c2.charAt(0)) + Math.floor(c2.charAt(1));

	remander = (10 - (Sum % 10)) % 10;

	if (Math.floor(vCompNo.charAt(9)) != remander) 
		return false;
	return true;
}

/*******************************************************************************
 ★ 설명
    법인 등록번호 확인
 ★ Parameter 
    1. sValue : 법인 등록 번호
 ★ return 
    - sValue가 법인등록번호 형식에 맞는 경우 = true
    - sValue가 법인등록번호 형식에 맞지 않는 경우 = false
    - sValue가 없는 경우 = false
******************************************************************************/ 
function IsCorpRegNo(sValue)
{
	if( IsNull(sValue) )	return false;
	
	var vCorpNo = sValue.replace("-", "");
	var checkID = new Array(1,2,1,2,1,2,1,2,1,2,1,2);
	var i, Sum=0, c2, remander;
	
	if (vCorpNo.length != 13) 
		return false; 
	
	for (i = 0; i <= 12; i++) 
		Sum += checkID[i] * vCorpNo.charAt(i);
	
	remander = Sum / 10;
	var nIndex = remander.toString().indexOf(".");	
	remander = remander.toString().substring(nIndex+1,nIndex+2);
	remander = 10 - remander; 
	
	if (remander > 9 ) 
		remander = 0;
	if (remander == sValue.substring(12, 13)) 
		return true;

	return false
}

/*******************************************************************************
 ★ 설명
    주민 등록번호 확인
 ★ Parameter 
    1. sValue : 주민 등록 번호
 ★ return 
    - sValue가 주민등록번호 형식에 맞는 경우 = true
    - sValue가 주민등록번호 형식에 맞지 않는 경우 = false
    - sValue가 없는 경우 = false
******************************************************************************/ 
function IsRsrNo(sValue)
{
	if( IsNull(sValue) )	return false;
	
    var v_JuminNo = sValue.replace("-", "");
	var v_JuminChkDgt = [2,3,4,5,6,7,8,9,2,3,4,5];
	var v_FNum = new Number();
	var v_LNum = new Number();
	var v_iSum = new Number();
	var v_RtnVal;
	var v_YY;

    if(v_JuminNo.length != 13) 
        return false;
	
	v_FNum = v_JuminNo.substr(0, 6).toString();
	v_LNum = v_JuminNo.substr(6).toString();
  
    if (v_LNum.substr(0,1) == '1' ||  v_LNum.substr(0,1) == '2')
        v_YY  = '19';
    else if (v_LNum.substr(0,1) == '3' ||  v_LNum.substr(0,1) == '4') 
        v_YY  = '20';
    else
		return false;
    
    if(IsDate(v_YY + v_FNum) == false)
		return false;

    if (IsNum(v_JuminNo) == false)
		return false;

	for ( ix = 0; ix < 12 ; ix++)
		v_iSum += (parseInt(v_JuminNo.substr(ix, 1)) * v_JuminChkDgt[ix]);
		
	v_iSum = 11 - (v_iSum%11);
	v_iSum = v_iSum % 10;
	if (v_iSum != (parseInt(v_JuminNo.substr(12, 1))))
		return false;

	return true; 
}


/*******************************************************************************
 ★ 설명
    Email 적합여부 확인
 ★ Parameter 
    1. sValue : Email ( 예 : "oju@yahoo.co.kr" )
 ★ return 
    - sValue가 Email형식에 맞는 경우 = true
    - sValue가 Email형식에 맞지 않는 경우 = false
    - sValue가 없는 경우 = false
 *****************************************************************************/ 
function IsEmail(sValue)
{   
	var vChk = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-._@";
	var i, pos, vEmailFirst, vEmailLast;
	
	if( IsNull(sValue) )	return false;
	
	for( i = 0 ; i < sValue.length ; i++)
	{
		if(vChk.indexOf(sValue.charAt(i)) < 0) 
			return false;
    }
    pos = Pos(sValue,"@");
    if( pos < 0 )
		return false;
		
	vEmailFirst = sValue.substr(0, pos);
	vEmailLast = sValue.substr(pos+1);
	if( vEmailFirst.length <= 0 || vEmailLast.length <= 0 )
		return false;
	if( Pos(vEmailLast, ".") <= 0 || Pos(vEmailLast, "..") >= 0 || Right(vEmailLast,1) == "." )
		return false;
	if( Pos(vEmailLast, "@") >= 0 )
		return false;
		
    return true;
}

////////////////////////////////////////////////////////////////////////////////
// Component관련 함수 Start
////////////////////////////////////////////////////////////////////////////////
/*******************************************************************************
 ★ 설명
     Grid Sorting하는 함수(Header Sorting여부 표시 포함)
 ★ parameter 
    1. obj:Grid : Grid Object ( 예 : Grid00 )
    2. e:GridClickEventInfo : Click Event Object ( Grid Onclick Envent의 Argument e )
    3. ASC_MARK : Ascending Mark (옵션 : Default = "▼")( 예 : "▼" )
    4. DESC_MARK : Descending Mark (옵션 : Default = "▲")( 예 : "▲" )
    5. sSortMark    : Sorting 강제 지정 (옵션 : Default = "" ==> 상태에 따라 알아서 함)
                      (예 : ASC_MARK 또는 DESC_MARK 지정 )
 ★ return 
    - 성공 = true
    - 실패 = false
 ******************************************************************************/ 
function GridSort(obj:Grid, e:GridClickEventInfo, ASC_MARK, DESC_MARK, sSortMark)
{
	if( IsNull(obj) || IsNull(e) )	return false;
	
	// 컬럼의 정렬방식을 'head'의 text에 "↑,↓"여부로 판단.
	// 이미지로 대체 가능.
	var bindDs = eval(obj.binddataset);
	var i, cell_cnt;
	
	if (bindDs.rowcount == 0) return false;
	if( IsNull(ASC_MARK) )		ASC_MARK = "▼";
	if( IsNull(DESC_MARK) )		DESC_MARK = "▲";
	
	cell_cnt = obj.getCellCount("head");
	var BodyColId = (obj.getCellProperty("body", e.col,"text")).toString().split(":");	// e.col : 바인드된 컬럼.
																					
	for( i = 0 ; i < cell_cnt ; i++ ) 
	{
		if(obj.getCellText(-1, i)=="undefined")
			continue;
		
		var strHeadText = obj.getCellText(-1, i);	

		if(i==e.cell)
		{
			if(strHeadText.substr(strHeadText.length-1) == ASC_MARK) 
			{
				if( IsNull(sSortMark) || sSortMark == DESC_MARK )
				{
					obj.setCellProperty( "head", i, "text", strHeadText.substr(0, strHeadText.length - 1)+DESC_MARK);
					bindDs.keystring = "S:-"+BodyColId[1];
				}
			}
			else if (strHeadText.substr(strHeadText.length-1) == DESC_MARK) 
			{
				if( IsNull(sSortMark) || sSortMark == ASC_MARK )
				{
					obj.setCellProperty( "head", i, "text", strHeadText.substr(0, strHeadText.length - 1)+ASC_MARK);
					bindDs.keystring = "S:+"+BodyColId[1];
				}
			}
			else
			{
				var def_mark;
				if( IsNull(sSortMark) )	def_mark = ASC_MARK;
				else					def_mark = sSortMark;
					
				obj.setCellProperty( "head", i, "text", strHeadText+def_mark);
				if( def_mark == ASC_MARK )
					bindDs.keystring = "S:+"+BodyColId[1];
				else 
					bindDs.keystring = "S:-"+BodyColId[1];
			}
		}
		else	// 정렬표시 삭제
		{
			if (strHeadText.substr(strHeadText.length-1) == ASC_MARK || strHeadText.substr(strHeadText.length-1) == DESC_MARK) 
			{
				obj.setCellProperty( "head", i, "text", strHeadText.substr(0, strHeadText.length - 1));
			}
		}
	}
	return true;
}

/*********************************************************************************************
 ★ 설명
     Grid Excel Export하는 함수
 ★ parameter 
    1. obj:Grid : Grid Object ( 예 : Grid00 )
    2. ExpObj:ExportObject : Export Object (옵션 : Default는 생성해서 처리됨)
    3. sSheetName : Sheet 명 ( 옵션 : Default="Sheet1" )
 ★ return 
    - 성공 = true
    - 실패 = false
*********************************************************************************************/
function GridExportExcel(obj:Grid, ExpObj:ExportObject, sSheetName) 
{


	if( IsNull(obj)	)	return false;
	
	if( IsNull(ExpObj) == true )	
		var ExpObj = new ExportObject;
	if( IsNull(sSheetName) == true )
		sSheetName = "Sheet1";
		
	ExpObj.exportfilename = Grid.name+".xls"; 	// 꼭 줘야됨
	ExpObj.exporttype     = ExportTypes.EXCEL;	// 현재 Excel만 가능합니다.	
	ExpObj.activepagename = sSheetName;
	
	ExpObj.addExportItem(ExportItemTypes.GRID, obj, sSheetName+"!A1");	
	ExpObj.export();	// Excel로 Export실행

	return true;
}

/*********************************************************************************************
 ★ 설명
     Grid로 Treeview처리 시 nCurRow의 sLevelCol에 해당하는 현재 Level보다 
     0 ~ (nCurRow-1) Record중 더 상위의 Level(bFlag에 따라)에  해당하는 Record를 
     모두 구해 Array로 Return한다.
 ★ parameter 
    1. obj:Dataset : Dataset Object ( 예 : Dataset00 )
    2. sLevelCol   : Level값이 들어있는 Column명 ( 예 : "level" )    
    3. nCurrow     : 현재 Record ( 예 : 10 )
    4. bInclude    : 현재 level을 포함할 지 여부 ( 예 : true ) ( Default = true )
                     - true = 상위의 Level을 찾을 때 nCurRow Level과 동일한 Level도 포함
                     - false = 상위의 Level을 찾을 때 nCurRow Level과 동일한 Level은 포함 안함
 ★ return 
    - 성공 = Array ( record번호만 들어있음 )
    - 실패 = 빈 Array
*********************************************************************************************/
function TreeGetParentList(obj:Dataset, sLevelCol, nCurRow, bInclude) 
{
	var i, nLevel, nChkLevel;
	var aRet = new Array(), aNo=0;
	var bFlag;
	
	if( IsNull(obj) || IsNull(sLevelCol) || IsNull(nCurRow) )
		return aRet;
		
	if( IsNull(bInclude) == true )	bInclude = true;
	
	if( bInclude == true )
		nChkLevel = parseInt(obj.getColumn(nCurRow, sLevelCol));
	else
		nChkLevel = parseInt(obj.getColumn(nCurRow, sLevelCol))-1;
	for( i = (nCurRow-1) ; i >= 0 ; i-- )
	{
		nLevel = parseInt(obj.getColumn(i, sLevelCol));
		if( nLevel <= nChkLevel )
		{
			aRet[aNo] = i;
			aNo++;
			nChkLevel = nLevel;
		}
	}
	return aRet.sort();
}

/*********************************************************************************************
 ★ 설명
     Grid로 Treeview처리 시 0 ~ (nCurRow-1)의 Record중
     nOffsetLevel에 해당하는 시작 부모 Record를 찾는다.
 ★ parameter 
    1. obj:Dataset : Dataset Object ( 예 : Dataset00 )
    2. sLevelCol   : Level값이 들어있는 Column명 ( 예 : "level" )    
    3. nCurrow     : 현재 Record ( 예 : 10 )
    4. nOffsetLevel    : 양수(0, 음수는 안됨)에 해당하는 검색할 Offset Level ( 옵션 : Default = 1 )
                         ( 예 : 1 = 나보다 1 Level 위의 Parent의 시작 Record를 찾으라는 뜻 )
 ★ return 
    - 성공 = Start Record
    - 실패 = -1
 ★ 주의사항
    nOffsetLevel은 0 또는 음수를 주면 안된다.
*********************************************************************************************/
function TreeGetParentStart(obj:Dataset, sLevelCol, nCurRow, nOffsetLevel) 
{
	var i, nLevel, nChkLevel, nStartRow = -1;
	
	if( IsNull(obj) || IsNull(sLevelCol) || IsNull(nCurRow) )
		return -1;

	if( IsNull(nOffsetLevel) == true )	nOffsetLevel = 1;
	if( nOffsetLevel <= 0 )		
		return -1;
	
	nChkLevel = parseInt(obj.getColumn(nCurRow, sLevelCol)) - nOffsetLevel;
	for( i = (nCurRow-1) ; i >= 0 ; i-- )
	{
		nLevel = parseInt(obj.getColumn(i, sLevelCol));
		if( nLevel == nChkLevel )
		{
			nStartRow = i;
			break;
		}
		if( nLevel < nChkLevel )
			nChkLevel = nLevel;
	}
	
	return nStartRow;
}


/*********************************************************************************************
 ★ 설명
     Grid로 Treeview처리 시 nCurRow+1 ~ 끝 Record중
     nCurRow의 Level이하의 Child Level이 끝나는 Record를 찾는다.
     즉, 자식이 끝나는 Record를 찾는다.
 ★ parameter 
    1. obj:Dataset : Dataset Object ( 예 : Dataset00 )
    2. sLevelCol   : Level값이 들어있는 Column명 ( 예 : "level" )    
    3. nCurrow     : 현재 Record ( 예 : 10 )
 ★ return 
    - 성공 = End Record
    - 실패 = -1
*********************************************************************************************/
function TreeGetChildEnd(obj:Dataset, sLevelCol, nCurRow) 
{
	var i, nLevel, nChkLevel, nEndRow = (obj.rowcount - 1);
	
	if( IsNull(obj) || IsNull(sLevelCol) || IsNull(nCurRow) )
		return -1;
	
	nChkLevel = parseInt(obj.getColumn(nCurRow, sLevelCol));	

	for( i = (nCurRow+1) ; i < obj.rowcount ; i++ )
	{
		nLevel = parseInt(obj.getColumn(i, sLevelCol));
		if( nLevel <= nChkLevel )
		{
			nEndRow = i-1;
			break;
		}
	}
	
	return nEndRow;
}

/*********************************************************************************************
 ★ 설명
     GraphicPath의 그리기 영역을 구한다.
     GraphicPath에서 Border와 Pen의 크기를 뺀 영역을 의미한다.
 ★ parameter 
    1. obj : GraphicPath Object ( 예 : GraphicPath00 )
    2. nLeftOffset : GrapicPath의 영역 중 Left에서 안쪽으로 들어가는 Offset값
					 (옵션 : Default = 0) (예 : nLeftOffset=10이면 10만큼 Left에서 떨어진 지점이 영역으로 잡힘)
    3. nTopOffset : GrapicPath의 영역 중 Top에서 안쪽으로 들어가는 Offset값
					(옵션 : Default = 0) (예 : nTopOffset=10이면 10만큼 Top에서 떨어진 지점이 영역으로 잡힘)
    4. nRightOffset : GrapicPath의 영역 중 Right에서 안쪽으로 들어가는 Offset값
					(옵션 : Default = nLeftOffset) (예 : nLeftOffset=10이면 10만큼 Right에서 떨어진 지점이 영역으로 잡힘)
    5. nBottomOffset : GrapicPath의 영역 중 Bottom에서 안쪽으로 들어가는 Offset값
					(옵션 : Default = nBottomOffset) (예 : nLeftOffset=10이면 10만큼 Bottom에서 떨어진 지점이 영역으로 잡힘)★ return 
 ★ Return    					
    - 성공 = Rect Object
    - 실패 = null 
			(단, offset이 너무커서 width나 height값보다 클 경우도 null이 return된다.)
 ★ 목적    
    GraphicPath.position을 이용하여 그리면 제대로 안되는 것을 알 수 있다. 그래서, 만들었다. Offset도 줄겸
 
*********************************************************************************************/
function GPRect(obj:GraphicPath, nLeftOffset, nTopOffset, nRightOffset, nBottomOffset)
{
	var GR = new Rect();
	var border, pen;
	
	if( IsNull(obj) ) 	return null;
	
	if( IsNull(nLeftOffset) )	nLeftOffset = 0;
	if( IsNull(nTopOffset) )	nTopOffset = 0;
	if( IsNull(nRightOffset) )	nRightOffset = nLeftOffset;
	if( IsNull(nBottomOffset) )	nBottomOffset = nTopOffset;

	border = ( "x"+obj.style.border.width == "xNaN" ? 0 : obj.style.border.width );
	pen = ( "x"+obj.strokepen.width == "xNaN" ? 1 : obj.strokepen.width );
	GR.left = nLeftOffset;
	GR.top = nTopOffset;
	
	// 이렇게 하는게 최선이다.
	GR.right = obj.position.width - nRightOffset - 2*border - pen;
	GR.bottom = obj.position.height - nBottomOffset - 2*border - pen;
	if( GR.width < 0 || GR.height < 0 )
		return null;
	
	return GR;
}

/*********************************************************************************************
 ★ 설명
     GraphicPath처리 시 화살표처리 Data를 만들어 준다.
     이미 그려놓은 GraphicPath.data에 이 함수에서 return된 data를 덧붙여 처리해서 사용한다.
 ★ parameter 
    1. obj:GraphicPath : GraphicPath Object ( 예 : GraphicPath00 )
    2. nArrowType  : 화살표의 종류( 예 : 1 )
       - 0 = 화살표 안그림
       - 1 = ---> 화살표
       - 2 = ---▶ 화살표
       - 3 = ---◆ 화살표
       - 4 = ---● 화살표
    3. nEndX, nEndY, nDirAngle : 화살표의 위치 및 화살표 방향
       - nEndX, nEndY : 화살표의 끝좌표
       - nAngle       : 화살표의 방향, 단 Radian값이다.
                        화살표 끝좌표의 가로축과 시작방향이 이루는 각이다.
                        (※ GetAngle()함수를 이용하면 쉽게 구할 수 있다.)
       (예 : (15,15) ----> (20,20) 으로 화살표를 그리고 싶다면
             nEndX = 20, nEndY = 20, nAngle = Deg2Rad(-45) )
    4. 화살표가 그려질 선을 중심으로 화살표의 넓이와 높이
       1) nArrowW : 화살표 넓이
       2) nArrowH : 화살표 높이
       (※ 단, ---●의 경우 타원처리는 안되고 nArrowW, nArrowH중 작은 쪽을 반지름으로 하는 원만 처리한다. )
                    (20)
       (예 : -----(0)▶(10) ==> nArrowW = 10, nArrowH = 20 )
                     (0)
                    (20)
       (예 : -----(0)◆(10) ==> nArrowW = 10, nArrowH = 20 )
                     (0)
 ★ return 
    - 성공 = GraphicPath.data에 들어갈 화살표 Data
    - 실패 = ""
*********************************************************************************************/
function GPArrow(obj:GraphicPath, nArrowType,
					nEndX, nEndY, nAngle, nArrowW, nArrowH )
{
	var D="";
	
	var nDirX, nDirY;
	var nArrowOrgX, nArrowOrgY, nArrowCoW, nArrowCoH, nArrowDist;
	var nArrowType;

	if( IsNull(obj) || IsNull(nArrowType) || IsNull(nEndX) || IsNull(nEndY) || 
		IsNull(nAngle) || IsNull(nArrowW) || IsNull(nArrowH) )
		return "";
		
	// ->, ▶
	if( nArrowType == 1 || nArrowType == 2 )	
	{
		nArrowCoW = nArrowW;
		nArrowCoH = Math.round(nArrowH/2,1);
	}
	// ◆, ●
	else if( nArrowType == 3 || nArrowType == 4 )
	{
		nArrowCoW = Math.round(nArrowW/2,1);
		nArrowCoH = Math.round(nArrowH/2,1);		
	}
	else
		return "";
	
	if( nArrowType == 4 )
		nArrowDist = Math.min(nArrowW,nArrowH);
	else
		nArrowDist = Math.sqrt(Math.pow(nArrowCoW,2)+Math.pow(nArrowCoH,2));
	nArrowOrgX = nEndX + nArrowDist*Math.cos(nAngle);
	nArrowOrgY = nEndY - nArrowDist*Math.sin(nAngle);
/*	
D  = " M " + nEndX + " " + nEndY;
D += " L " + nArrowOrgX + " " + nArrowOrgY;
return D;
*/
	// ->
	if( nArrowType == 1 )
	{
		var nArrowAngle, vRotatePoint1, vRotatePoint2;	
		
		nArrowAngle = Math.atan2(nArrowCoH,nArrowCoW);
		vRotatePoint1 = RotatePoint( nArrowOrgX, nArrowOrgY, nEndX, nEndY, nArrowAngle );
		vRotatePoint2 = RotatePoint( nArrowOrgX, nArrowOrgY, nEndX, nEndY, -1*nArrowAngle );		
					
		D += " M " + nEndX + " " + nEndY;		
		D += " L " + vRotatePoint1.left + " " + vRotatePoint1.top;
		D += " M " + nEndX + " " + nEndY;				
		D += " L " + vRotatePoint2.left + " " + vRotatePoint2.top;
	}
	// ▶
	if( nArrowType == 2 )
	{
		var nArrowAngle, vRotatePoint1, vRotatePoint2;	
	
		nArrowAngle = Math.atan2(nArrowCoH,nArrowCoW);
		vRotatePoint1 = RotatePoint( nArrowOrgX, nArrowOrgY, nEndX, nEndY, nArrowAngle );
		vRotatePoint2 = RotatePoint( nArrowOrgX, nArrowOrgY, nEndX, nEndY, -1*nArrowAngle );		

		D += " M " + nEndX + " " + nEndY;		
		D += " L " + vRotatePoint1.left + " " + vRotatePoint1.top;
		D += " L " + vRotatePoint2.left + " " + vRotatePoint2.top;
		D += " L " + nEndX + " " + nEndY;				
	}
	// ◆
	if( nArrowType == 3 )
	{
		var nArrowAngle, vRotatePoint1, vRotatePoint2, vRotatePoint3;	
		
		nArrowAngle = Math.atan2(nArrowCoH,nArrowCoW);
		vRotatePoint1 = RotatePoint( nArrowOrgX, nArrowOrgY, nEndX, nEndY, nArrowAngle );
		vRotatePoint2 = RotatePoint( nArrowOrgX, nArrowOrgY, nEndX, nEndY, -1*nArrowAngle );
		vRotatePoint3 = RotatePoint( nEndX, nEndY, vRotatePoint1.left, vRotatePoint1.top, Math.PI-2*nArrowAngle );
		
		D += " M " + nEndX + " " + nEndY;		
		D += " L " + vRotatePoint1.left + " " + vRotatePoint1.top;
		D += " L " + vRotatePoint3.left + " " + vRotatePoint3.top;
		D += " L " + vRotatePoint2.left + " " + vRotatePoint2.top;
		D += " L " + nEndX + " " + nEndY;			
	}
	// ●
	if( nArrowType == 4 )
	{
		var nRX, nRY;

		nRX = nRY = Math.min(nArrowCoW,nArrowCoH);
		D += " M " + nEndX + " " + nEndY;	
		D += " A " + nRX + " " + nRY + " 180 0 1 " + nArrowOrgX + " " + nArrowOrgY;		
		D += " A " + nRX + " " + nRY + " 180 0 1 " + nEndX + " " + nEndY;				
	}
	return D;
}

/*********************************************************************************************
 ★ 설명
     GraphicPath.data를 2차원 Array로 반환한다.
     단순히 Parsing만 하며 Array의 순서는 GraphicPath.data의 순서를 그대로 따른다.
     단, type이 중복되어 생략되는 경우(예: V 100 100) Array가 추가되고 첫번째 요소는 ""가 들어간다.
     (아래 예를 참고할것)
 ★ parameter 
    1. sGpData : GraphicPath.data ( 예 : "M 0 0 L 100 100 H 100 V 100 100" )
 ★ return 
    - 성공 = 2차원 Array 
             ( 예 : Array ==> { {M,0,0}, {L,100,100}, {H,100}, {V,100}, {,100} }
    - 실패 = 빈 Array
 ★ 목적    
    GraphicPathData Object가 있었다가 사라졌다.
 ★ 참고사항
    aGpData로 data문자열을 만들고 싶다면 ==> GraphicPath.data = aGpData.join(" "); 로 처리하면 된다.
 ********************************************************************************************/
function AGPData(sGpData)
{
	var aGpData = new Array();
	var arr = new Array();
	var i, gi_no=-1, ho_no, val, sType, ho_num;
	
	if( IsNull(sGpData) ) 	return aGpData;

	sGpData = sGpData.toString();
	arr = sGpData.split(" ");
	for( i = 0 ; i < arr.length ; i++ )
	{
		val = RTrim(LTrim(arr[i]));
		if( IsAlpha(val) == true )
		{
			gi_no++;
			ho_no = 0;
			
			var aHor = new Array();	// 2차원 배열의 가로 배열
			aGpData[gi_no] = aHor;
			aGpData[gi_no][ho_no] = val;
			sType = val;
		}
		else if( IsNum(val) == true )
		{
			ho_no++;		
			if( ( (sType == "M" || sType == "m") && ho_no == 3) ||
				( (sType == "L" || sType == "l") && ho_no == 3) ||
				( (sType == "H" || sType == "h") && ho_no == 2) ||
				( (sType == "V" || sType == "v") && ho_no == 2) ||
				( (sType == "A" || sType == "a") && ho_no == 8) ||
				( (sType == "C" || sType == "c") && ho_no == 7) )
			{
				gi_no++;
				ho_no = 0;

				var aHor1 = new Array();	// 2차원 배열의 가로 배열
				aGpData[gi_no] = aHor1;
				aGpData[gi_no][ho_no] = "";				
				ho_no++;
				aGpData[gi_no][ho_no] = parseInt(val);
			}
			else
			{
				aGpData[gi_no][ho_no] = parseInt(val);
			}
		}
	}

	return aGpData;
}

/*********************************************************************************************
 ★ 설명
     aGpData에 해당하는 도형을 nCx, nCy를 기준으로 nAngle만큼 회전한다.
     단, AGPData()에 의해 발생한 Array를 사용해야만 한다. 
     또한, aGpData자체를 바꾸어 return한다.
 ★ parameter 
    1. aGpData : 반드시 AGPData()에 의해 발생한 Array 
    2. nAngle : 회전각, Radian
    3. nCx : 회전 중심 X좌표
    4. nCy : 회전 중심 Y좌표
 ★ return 
    - 성공 = 회전된 2차원 Array = aGpData ( ※ aGpResetData를 바꾸어 return한다. )
    - 실패 = 빈 Array
 ★ 주의사항
    1. 메모리 낭비를 줄이기 위해 aGpData를 직접바꾸게 되므로 보관 잘 할것
    2. Parameter의 aGpData는 반드시 AGPReset()에 의해 발생한 Array이어야 한다.        

 ********************************************************************************************/
 /**************** 빼버렸음
function GPRotate( aGpData, nAngle, nCx, nCy )
{
	var i, sType;
	var aGpResetData;
	var vRot;		// Rotation좌표
	
	if( IsNull(aGpData) || IsNull(nAngle) || IsNull(nCx) || IsNull(nCy) )		
		return (new Array());

	aGpResetData = _AGPReset(aGpData);
	if( aGpResetData.length == 0 )		return (new Array());
	// 회전 좌표 얻어오기
	for( i = 0 ; i < aGpResetData.length ; i++ )
	{
		sType = aGpResetData[i][0].toUpperCase();
		if( sType == "M" || sType == "L" || sType == "C" )
		{
			vRot = RotatePoint(aGpResetData[i][1], aGpResetData[i][2], nCx, nCy, nAngle);
			aGpResetData[i][1] = vRot.left;
			aGpResetData[i][2] = vRot.top;
		}
		if( sType == "C" )
		{
			vRot = RotatePoint(aGpResetData[i][3], aGpResetData[i][4], nCx, nCy, nAngle);
			aGpResetData[i][3] = vRot.left;
			aGpResetData[i][4] = vRot.top;
			aRot = RotatePoint(aGpResetData[i][5], aGpResetData[i][6], nCx, nCy, nAngle);
			aGpResetData[i][5] = vRot.left;
			aGpResetData[i][6] = vRot.top;			
		}
		if( sType == "A" )
		{
			vRot = RotatePoint(aGpResetData[i][6], aGpResetData[i][7], nCx, nCy, nAngle);
			aGpResetData[i][6] = vRot.left;
			aGpResetData[i][7] = vRot.top;
		}
	}
	
	return aGpResetData;
}
************************/
/*********************************************************************************************
 ★ 설명
     aGpData에 해당하는 도형의 좌표들을 이동한다.
     단, AGPData()에 의해 발생한 Array를 사용해야만 한다. 
     또한, aGpData자체를 바꾸어 return한다.
 ★ parameter 
    1. aGpData : 반드시 AGPData()에 의해 발생한 Array 
	2. nOffsetX, nOffsetY : 현재 상태를 기준으로 이동할 X축, Y축 길이
	                 (단, 왼쪽으로 이동하려면 nOffsetX를 음수로,
	                      위쪽으로 이동하려면 nOffsetY를 음수로 주면됨)
 ★ return 
    - 성공 = 이동된 2차원 Array = aGpData ( ※ aGpResetData를 바꾸어 return한다. )
    - 실패 = 빈 Array
 ★ 주의사항
    1. 메모리 낭비를 줄이기 위해 aGpData를 직접바꾸게 되므로 보관 잘 할것
    2. Parameter의 aGpData는 반드시 AGPReset()에 의해 발생한 Array이어야 한다.    
 ********************************************************************************************/
 /********************** 빼버렸다
function GPMove( aGpData, nOffsetX, nOffsetY )
{
	var i, sType;
	
	if( IsNull(aGpData) || IsNull(nOffsetX) || IsNull(nOffsetY) )
		return (new Array() );

	aGpResetData = _AGPReset(aGpData);
	if( aGpResetData.length == 0 )		return (new Array());
	
	// 이동 좌표 얻어오기
	for( i = 0 ; i < aGpResetData.length ; i++ )
	{
		sType = aGpResetData[i][0].toUpperCase();
		if( sType == "M" || sType == "L" || sType == "C" )
		{
			aGpResetData[i][1] += nOffsetX;
			aGpResetData[i][2] += nOffsetY;
		}
		if( sType == "C" )
		{
			aGpResetData[i][3] += nOffsetX;
			aGpResetData[i][4] += nOffsetY;
			aGpResetData[i][5] += nOffsetX;
			aGpResetData[i][6] += nOffsetY;			
		}
		if( sType == "A" )
		{
			aGpResetData[i][6] += nOffsetX;
			aGpResetData[i][7] += nOffsetY;
		}
	}
	
	return aGpResetData;
}
***********************/

/*********************************************************************************************
 ★ Logic이 복잡해서 중단한다. 지겹다.
 ★ 설명
     aGpResetData에 해당하는 도형의 좌표들을 nCX, nCY를 중심으로 확대/축소한다.
     단, AGPReset()에 의해 발생한 Array를 사용해야만 한다. 
     또한, aGpResetData자체를 바꾸어 return한다.
 ★ parameter 
    1. aGpResetData : 반드시 AGPReset()에 의해 발생한 Array 
				     ( 예 : { {M,0,0},{L,100,100} } )
	2. nOffsetX, nOffsetY : 현재 상태를 기준으로 확대/축소할 X축, Y축 길이
	                 (단, X축방향에 대해 축소하려면 nOffsetX를 음수로,
	                      Y축방향에 대해 축소하려면 nOffsetY를 음수로 주면됨)
	3. nCX, nCY     : 확대 축소할 중앙점 좌표 	                      
 ★ return 
    - 성공 = 이동된 2차원 Array = aGpResetData ( ※ aGpResetData를 바꾸어 return한다. )
             ( 예 : Array ==> { {M,0,0},{L,100,100},{L,200,100},{L,200,200},{L,300,300,200,200} }
    - 실패 = null
 ★ 주의사항
    1. Parameter의 aGpResetData는 반드시 AGPReset()에 의해 발생한 Array이어야 한다.
    2. aGpResetData자체를 바꾸게 되므로 필요시 보관절차를 취해야 한다.

 ********************************************************************************************/
/* 
function AGPResize( aGpData, nOffsetX, nOffsetY)
{

	var nCX, nCY;
	var i, j, sType;
	
	if( IsNull(aGpData) || IsNull(nOffsetX) || IsNull(nOffsetY) )
		return (new Array() );

	aGpResetData = _AGPReset(aGpData);
	if( aGpResetData.length == 0 )		return (new Array());
	
	// Center좌표 계산하기
	var nMinX=0, nMaxX=0, nMinY=0, nMaxY=0;
	for( i = 0 ; i < aGpResetData.length ; i++ )
	{
		sType = aGpResetData[i][0].toUpperCase();
		if( sType == "M" || sType == "L" || sType == "C" )
		{
			nMinX = Math.min(nMinX, aGpResetData[i][1]);
			nMaxX = Math.max(nMaxX, aGpResetData[i][1]);
			nMinY = Math.min(nMinY, aGpResetData[i][2]);
			nMaxY = Math.max(nMaxY, aGpResetData[i][2]);
		}
		if( sType == "C" )
		{
			noX[0] = 3; 	noY[0] = 4;	aOffsetX[0] = nOffsetX;		aOffsetY[0] = nOffsetY;
			noX[1] = 5;		noY[1] = 6;	aOffsetX[1] = nOffsetX;		aOffsetY[1] = nOffsetY;
		}
		if( sType == "A" )
		{
			noX[0] = 6;		noY[0] = 7; aOffsetX[0] = nOffsetX;		aOffsetY[0] = nOffsetY;
//			noX[1] = 1;		noY[1] = 2; aOffsetX[1] = nOffsetX/2;		aOffsetY[1] = nOffsetY/2;
		}
		for( j = 0 ; j < noX.length ; j++ )
		{
			if( aGpResetData[i][noX[j]] < nCX )
				aGpResetData[i][noX[j]] -= aOffsetX[j];
			if( aGpResetData[i][noX[j]] > nCX )
				aGpResetData[i][noX[j]] += aOffsetX[j];
		}
		for( j = 0 ; j < noY.length ; j++ )
		{
			if( aGpResetData[i][noY[j]] < nCY )
				aGpResetData[i][noY[j]] -= aOffsetY[j];
			if( aGpResetData[i][noY[j]] > nCY )
				aGpResetData[i][noY[j]] += aOffsetY[j];
		}
	}
	
	var noX = new Array(), noY = new Array();
	var aOffsetX = new Array(), aOffsetY = new Array();
	
	// 이동 좌표 얻어오기
	for( i = 0 ; i < aGpResetData.length ; i++ )
	{
		sType = aGpResetData[i][0].toUpperCase();
		if( sType == "M" || sType == "L" || sType == "C" )
		{
			noX[0] = 1;		noY[0] = 2;	aOffsetX[0] = nOffsetX;		aOffsetY[0] = nOffsetY;
		}
		if( sType == "C" )
		{
			noX[0] = 3; 	noY[0] = 4;	aOffsetX[0] = nOffsetX;		aOffsetY[0] = nOffsetY;
			noX[1] = 5;		noY[1] = 6;	aOffsetX[1] = nOffsetX;		aOffsetY[1] = nOffsetY;
		}
		if( sType == "A" )
		{
			noX[0] = 6;		noY[0] = 7; aOffsetX[0] = nOffsetX;		aOffsetY[0] = nOffsetY;
//			noX[1] = 1;		noY[1] = 2; aOffsetX[1] = nOffsetX/2;		aOffsetY[1] = nOffsetY/2;
		}
		for( j = 0 ; j < noX.length ; j++ )
		{
			if( aGpResetData[i][noX[j]] < nCX )
				aGpResetData[i][noX[j]] -= aOffsetX[j];
			if( aGpResetData[i][noX[j]] > nCX )
				aGpResetData[i][noX[j]] += aOffsetX[j];
		}
		for( j = 0 ; j < noY.length ; j++ )
		{
			if( aGpResetData[i][noY[j]] < nCY )
				aGpResetData[i][noY[j]] -= aOffsetY[j];
			if( aGpResetData[i][noY[j]] > nCY )
				aGpResetData[i][noY[j]] += aOffsetY[j];
		}
	}
	
	return aGpResetData;
}
*/

////////////////////////////////////////////////////////////////////////////////
// Component관련 함수 End
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// 내부에서만 사용하는 함수 Start
////////////////////////////////////////////////////////////////////////////////
/*******************************************************************************
 ★ 설명
    Dialog(), Open()실행용 공통함수.
    ※ 단, 내부에서 사용하는 함수임     
 ★ parameter 
    1. sID     : Dialog ID ( 예 : "id1" )         
    2. sURL    : Form URL ( 예 : "Base::a.xfdl" )
    3. Arg    : Dialog 로 전달될 Argument  
                 ( 예1 : {a:'b',c:'d'}  ==> 꼭, {}로 싸야 되고 위의 예 처럼 해야 된다. )
                 ( 예2 : var arr = new Array();
						arr["a"] = "b";
						arr["c"] = "d";  ==> 이래 한 후에 arr넘김 )

    4. nLeft   : Dialog창의 Left Position ( 옵션 : Default = 현재화면 중앙 ) ( 예 : -1 또는 100 )
                 (단, 음수또는 null이면 현재화면 중앙에 위치)
    5. nTop    : Dialog창의 Top Position ( 옵션 : Default = 현재화면 중앙 ) ( 예 : -1 또는 100 )
                 (단, 음수또는 null이면 현재화면 중앙에 위치)
    6. nWidth  : Dialog창의 Width ( 옵션 : Default = Popup화면의 width ) ( 예 : -1 또는 100 )
                 (단, 음수또는 null이면 Popup화면의 width)
    7. nHeight : Dialog창의 Height ( 옵션 : Default = Popup화면의 height ) ( 예 : -1 또는 100 )
				 (단, 음수또는 null이면 Popup화면의 width)
    8. sStyle  : Dialog Open 기본 유형 (옵션 : Default = "" ) ( 예 : "title=true,status=true" )
                 (단, 간단히 지정하도록 처리했으므로 ChildFrame의 Property명과 동일하지는 않다.)
        - title  : Title Bar표시여부 ( Default = true ) ( true = Title Bar 표시 )
        - status : Status Bar표시여부 ( Default = true ) ( true = Status Bar 표시 )
        - close  : Close Button활성화 여부 ( Default = true ) ( true = Close Button활성화 )
        - min    : min Button활성화 여부 ( Default = true )  ( true = Min Button 활성화 )      
        - max    : min Button활성화 여부 ( Default = true )  ( true = Max Button 활성화 )              
    9. sProp   : Child Frame의 모든 Property를 Property명=Property값, Property명=Property값,... 형태로 설정한다.
                 (옵션 : Default = "") ( 예 : "titletext='a', style.border='1 solid blue', ... )
                 ( 단, sStyle에 동일한 처리가 있으면 sProp가 적용된다. 
                   즉, sStyle="title=true", sProp="showtitlebar=false"라면 Title Bar는 표시되지 않는다.
 ★ return 
    - 성공 = Child Frame Object
    - 실패 = null
 ★ 주의사항
    1. nLeft, nTop이 null이거나 음수이면 현재화면의 중앙에 위치함
    2. nWidth, nHeight이 하나라도 null이거나 음수이면 Popup화면의 width, height가 설정됨
       따라서, nWidth, nHeight를 설정하고 싶으면 두 값 모두 양수값을 확실히 설정해야 한다.
    3. 조금더, 자세하게 Popup화면을 제어하고 싶으면 ( 예를 들어, scrollbar, border등 )
       sProp에 지정하거나 Dialog창의 Frame을 얻어 직접제어할 것
    4. nLeft, nTop, nWidth, nHeight의 좌표계는 screen기준 좌표계임에 주의할것       
 ******************************************************************************/
function _NewChildFrame( sID, sURL, Arg, nLeft, nTop, nWidth, nHeight, sStyle, sProp)
{
	var newChild = null;
	var MyFrame = this.getOwnerFrame();
	
	var bTitle = true;
	var bStatus = true;
	var bClose = true;
	var bMin = true;
	var bMax = true;	
	var bAutoSize = true;	
	var flag;
	var aProp = new Array();

	if( IsNull(sID) || IsNull(sURL) )	return null;
	
	newChild = new ChildFrame;
		
	if( IsNull(nLeft) || nLeft < 0 )
		newChild.openalign.halign = "center";
	if( IsNull(nTop) || nTop < 0 )
		newChild.openalign.valign = "center";
	if( IsNull(nWidth) || nWidth < 0 ||
	    IsNull(nHeight) || nHeight < 0 )
	{
		nWidth = 0;
		nHeight = 0;
		bAutoSize = true;
	}
	else
		bAutoSize = false;
	if( IsNull(sStyle) == false )
	{
		var i, arr, arr1;
		arr = sStyle.split(",");
		for( i = 0 ; i < arr.length ; i++ )
		{
			arr1 = arr[i].split("=");
			arr1[0] = RTrim(LTrim(arr1[0]));
			arr1[1] = RTrim(LTrim(arr1[1]));		
			if( arr1[1].toLowerCase() == "true" )		flag = true;
			else										flag = false;
			
			if( arr1[0].toLowerCase() == "title" ) 		bTitle = flag;
			if( arr1[0].toLowerCase() == "status" ) 	bStatus = flag;
			if( arr1[0].toLowerCase() == "close" ) 		bClose = flag;			
			if( arr1[0].toLowerCase() == "min" ) 		bMin = flag;			
			if( arr1[0].toLowerCase() == "max" ) 		bMax = flag;						
		}
	}

	if( IsNull(sProp) == false )
	{
		var i;
		aProp = sProp.split(",");
		for( i = 0 ; i < aProp.length ; i++ )
		{
			aProp[i] = aProp[i].split("=");
			aProp[i][0] = RTrim(LTrim(aProp[i][0]));
			aProp[i][1] = RTrim(LTrim(aProp[i][1]));
		}
	}

	newChild.formurl = sURL;	
	
	////// sStyle내용 적용( 이부분은 init()호출전에 사용해야 함 )
	newChild.showtitlebar = bTitle;	
	newChild.showstatusbar = bStatus;			
	newChild.autosize = bAutoSize;
	
	newChild.init(sID, nLeft, nTop, nLeft + nWidth, nTop + nHeight);

	////// sStyle내용 적용( 이부분은 init()호출후에 사용해야 함 )
	newChild.titlebar.minbutton.enable = bMin;		
	newChild.titlebar.maxbutton.enable = bMax;		
	newChild.titlebar.closebutton.enable = bClose;	

	MyFrame.addChild(sID, newChild);	// 이거 꼭 해야 함
	////// sProp내용 적용
	for( i = 0 ; i < aProp.length ; i++ )
	{
		SetProp( "this.getOwnerFrame()."+sID, aProp[i][0], aProp[i][1] );
	}
	MyFrame.removeChild(sID);			// 이거 꼭 해야 함

	return newChild;
}

/*******************************************************************************
 ★ 설명
     각 월별 음력 기준 정보를 처리하는 함수(처리가능 기간  1841 - 2043년)
     단, 내부에서 사용하는 함수임     
 ★ parameter 
    1. 없음
 ★ return 
    - 성공 = 음력 기준정보
    - 실패 = 
 ******************************************************************************/
function _SolarBase()
{
	var kk;
	
	//1841
	kk = "1,2,4,1,1,2,1,2,1,2,2,1,";
	kk += "2,2,1,2,1,1,2,1,2,1,2,1,";
	kk += "2,2,2,1,2,1,4,1,2,1,2,1,";
	kk += "2,2,1,2,1,2,1,2,1,2,1,2,";
	kk += "1,2,1,2,2,1,2,1,2,1,2,1,";
	kk += "2,1,2,1,5,2,1,2,2,1,2,1,";
	kk += "2,1,1,2,1,2,1,2,2,2,1,2,";
	kk += "1,2,1,1,2,1,2,1,2,2,2,1,";
	kk += "2,1,2,3,2,1,2,1,2,1,2,2,";
	kk += "2,1,2,1,1,2,1,1,2,2,1,2,";
	//1851
	kk += "2,2,1,2,1,1,2,1,2,1,5,2,";
	kk += "2,1,2,2,1,1,2,1,2,1,1,2,";
	kk += "2,1,2,2,1,2,1,2,1,2,1,2,";
	kk += "1,2,1,2,1,2,5,2,1,2,1,2,";
	kk += "1,1,2,1,2,2,1,2,2,1,2,1,";
	kk += "2,1,1,2,1,2,1,2,2,2,1,2,";
	kk += "1,2,1,1,5,2,1,2,1,2,2,2,";
	kk += "1,2,1,1,2,1,1,2,2,1,2,2,";
	kk += "2,1,2,1,1,2,1,1,2,1,2,2,";
	kk += "2,1,6,1,1,2,1,1,2,1,2,2,";
	//1861
	kk += "1,2,2,1,2,1,2,1,2,1,1,2,";
	kk += "2,1,2,1,2,2,1,2,2,3,1,2,";
	kk += "1,2,2,1,2,1,2,2,1,2,1,2,";
	kk += "1,1,2,1,2,1,2,2,1,2,2,1,";
	kk += "2,1,1,2,4,1,2,2,1,2,2,1,";
	kk += "2,1,1,2,1,1,2,2,1,2,2,2,";
	kk += "1,2,1,1,2,1,1,2,1,2,2,2,";
	kk += "1,2,2,3,2,1,1,2,1,2,2,1,";
	kk += "2,2,2,1,1,2,1,1,2,1,2,1,";
	kk += "2,2,2,1,2,1,2,1,1,5,2,1,";
	//1871
	kk += "2,2,1,2,2,1,2,1,2,1,1,2,";
	kk += "1,2,1,2,2,1,2,1,2,2,1,2,";
	kk += "1,1,2,1,2,4,2,1,2,2,1,2,";
	kk += "1,1,2,1,2,1,2,1,2,2,2,1,";
	kk += "2,1,1,2,1,1,2,1,2,2,2,1,";
	kk += "2,2,1,1,5,1,2,1,2,2,1,2,";
	kk += "2,2,1,1,2,1,1,2,1,2,1,2,";
	kk += "2,2,1,2,1,2,1,1,2,1,2,1,";
	kk += "2,2,4,2,1,2,1,1,2,1,2,1,";
	kk += "2,1,2,2,1,2,2,1,2,1,1,2,";
	//1881
	kk += "1,2,1,2,1,2,5,2,2,1,2,1,";
	kk += "1,2,1,2,1,2,1,2,2,1,2,2,";
	kk += "1,1,2,1,1,2,1,2,2,2,1,2,";
	kk += "2,1,1,2,3,2,1,2,2,1,2,2,";
	kk += "2,1,1,2,1,1,2,1,2,1,2,2,";
	kk += "2,1,2,1,2,1,1,2,1,2,1,2,";
	kk += "2,2,1,5,2,1,1,2,1,2,1,2,";
	kk += "2,1,2,2,1,2,1,1,2,1,2,1,";
	kk += "2,1,2,2,1,2,1,2,1,2,1,2,";
	kk += "1,5,2,1,2,2,1,2,1,2,1,2,";
	//1891
	kk += "1,2,1,2,1,2,1,2,2,1,2,2,";
	kk += "1,1,2,1,1,5,2,2,1,2,2,2,";
	kk += "1,1,2,1,1,2,1,2,1,2,2,2,";
	kk += "1,2,1,2,1,1,2,1,2,1,2,2,";
	kk += "2,1,2,1,5,1,2,1,2,1,2,1,";
	kk += "2,2,2,1,2,1,1,2,1,2,1,2,";
	kk += "1,2,2,1,2,1,2,1,2,1,2,1,";
	kk += "2,1,5,2,2,1,2,1,2,1,2,1,";
	kk += "2,1,2,1,2,1,2,2,1,2,1,2,";
	kk += "1,2,1,1,2,1,2,5,2,2,1,2,";
	//1901
	kk += "1,2,1,1,2,1,2,1,2,2,2,1,";
	kk += "2,1,2,1,1,2,1,2,1,2,2,2,";
	kk += "1,2,1,2,3,2,1,1,2,2,1,2,";
	kk += "2,2,1,2,1,1,2,1,1,2,2,1,";
	kk += "2,2,1,2,2,1,1,2,1,2,1,2,";
	kk += "1,2,2,4,1,2,1,2,1,2,1,2,";
	kk += "1,2,1,2,1,2,2,1,2,1,2,1,";
	kk += "2,1,1,2,2,1,2,1,2,2,1,2,";
	kk += "1,5,1,2,1,2,1,2,2,2,1,2,";
	kk += "1,2,1,1,2,1,2,1,2,2,2,1,";
	//1911
	kk += "2,1,2,1,1,5,1,2,2,1,2,2,";
	kk += "2,1,2,1,1,2,1,1,2,2,1,2,";
	kk += "2,2,1,2,1,1,2,1,1,2,1,2,";
	kk += "2,2,1,2,5,1,2,1,2,1,1,2,";
	kk += "2,1,2,2,1,2,1,2,1,2,1,2,";
	kk += "1,2,1,2,1,2,2,1,2,1,2,1,";
	kk += "2,3,2,1,2,2,1,2,2,1,2,1,";
	kk += "2,1,1,2,1,2,1,2,2,2,1,2,";
	kk += "1,2,1,1,2,1,5,2,2,1,2,2,";
	kk += "1,2,1,1,2,1,1,2,2,1,2,2,";
	//1921
	kk += "2,1,2,1,1,2,1,1,2,1,2,2,";
	kk += "2,1,2,2,3,2,1,1,2,1,2,2,";
	kk += "1,2,2,1,2,1,2,1,2,1,1,2,";
	kk += "2,1,2,1,2,2,1,2,1,2,1,1,";
	kk += "2,1,2,5,2,1,2,2,1,2,1,2,";
	kk += "1,1,2,1,2,1,2,2,1,2,2,1,";
	kk += "2,1,1,2,1,2,1,2,2,1,2,2,";
	kk += "1,5,1,2,1,1,2,2,1,2,2,2,";
	kk += "1,2,1,1,2,1,1,2,1,2,2,2,";
	kk += "1,2,2,1,1,5,1,2,1,2,2,1,";
	//1931
	kk += "2,2,2,1,1,2,1,1,2,1,2,1,";
	kk += "2,2,2,1,2,1,2,1,1,2,1,2,";
	kk += "1,2,2,1,6,1,2,1,2,1,1,2,";
	kk += "1,2,1,2,2,1,2,2,1,2,1,2,";
	kk += "1,1,2,1,2,1,2,2,1,2,2,1,";
	kk += "2,1,4,1,2,1,2,1,2,2,2,1,";
	kk += "2,1,1,2,1,1,2,1,2,2,2,1,";
	kk += "2,2,1,1,2,1,4,1,2,2,1,2,";
	kk += "2,2,1,1,2,1,1,2,1,2,1,2,";
	kk += "2,2,1,2,1,2,1,1,2,1,2,1,";
	//1941
	kk += "2,2,1,2,2,4,1,1,2,1,2,1,";
	kk += "2,1,2,2,1,2,2,1,2,1,1,2,";
	kk += "1,2,1,2,1,2,2,1,2,2,1,2,";
	kk += "1,1,2,4,1,2,1,2,2,1,2,2,";
	kk += "1,1,2,1,1,2,1,2,2,2,1,2,";
	kk += "2,1,1,2,1,1,2,1,2,2,1,2,";
	kk += "2,5,1,2,1,1,2,1,2,1,2,2,";
	kk += "2,1,2,1,2,1,1,2,1,2,1,2,";
	kk += "2,2,1,2,1,2,3,2,1,2,1,2,";
	kk += "2,1,2,2,1,2,1,1,2,1,2,1,";
	//1951
	kk += "2,1,2,2,1,2,1,2,1,2,1,2,";
	kk += "1,2,1,2,4,2,1,2,1,2,1,2,";
	kk += "1,2,1,1,2,2,1,2,2,1,2,2,";
	kk += "1,1,2,1,1,2,1,2,2,1,2,2,";
	kk += "2,1,4,1,1,2,1,2,1,2,2,2,";
	kk += "1,2,1,2,1,1,2,1,2,1,2,2,";
	kk += "2,1,2,1,2,1,1,5,2,1,2,2,";
	kk += "1,2,2,1,2,1,1,2,1,2,1,2,";
	kk += "1,2,2,1,2,1,2,1,2,1,2,1,";
	kk += "2,1,2,1,2,5,2,1,2,1,2,1,";
	//1961
	kk += "2,1,2,1,2,1,2,2,1,2,1,2,";
	kk += "1,2,1,1,2,1,2,2,1,2,2,1,";
	kk += "2,1,2,3,2,1,2,1,2,2,2,1,";
	kk += "2,1,2,1,1,2,1,2,1,2,2,2,";
	kk += "1,2,1,2,1,1,2,1,1,2,2,1,";
	kk += "2,2,5,2,1,1,2,1,1,2,2,1,";
	kk += "2,2,1,2,2,1,1,2,1,2,1,2,";
	kk += "1,2,2,1,2,1,5,2,1,2,1,2,";
	kk += "1,2,1,2,1,2,2,1,2,1,2,1,";
	kk += "2,1,1,2,2,1,2,1,2,2,1,2,";
	//1971
	kk += "1,2,1,1,5,2,1,2,2,2,1,2,";
	kk += "1,2,1,1,2,1,2,1,2,2,2,1,";
	kk += "2,1,2,1,1,2,1,1,2,2,2,1,";
	kk += "2,2,1,5,1,2,1,1,2,2,1,2,";
	kk += "2,2,1,2,1,1,2,1,1,2,1,2,";
	kk += "2,2,1,2,1,2,1,5,2,1,1,2,";
	kk += "2,1,2,2,1,2,1,2,1,2,1,1,";
	kk += "2,2,1,2,1,2,2,1,2,1,2,1,";
	kk += "2,1,1,2,1,6,1,2,2,1,2,1,";
	kk += "2,1,1,2,1,2,1,2,2,1,2,2,";
	//1981
	kk += "1,2,1,1,2,1,1,2,2,1,2,2,";
	kk += "2,1,2,3,2,1,1,2,2,1,2,2,";
	kk += "2,1,2,1,1,2,1,1,2,1,2,2,";
	kk += "2,1,2,2,1,1,2,1,1,5,2,2,";
	kk += "1,2,2,1,2,1,2,1,1,2,1,2,";
	kk += "1,2,2,1,2,2,1,2,1,2,1,1,";
	kk += "2,1,2,2,1,5,2,2,1,2,1,2,";
	kk += "1,1,2,1,2,1,2,2,1,2,2,1,";
	kk += "2,1,1,2,1,2,1,2,2,1,2,2,";
	kk += "1,2,1,1,5,1,2,1,2,2,2,2,";
	//1991
	kk += "1,2,1,1,2,1,1,2,1,2,2,2,";
	kk += "1,2,2,1,1,2,1,1,2,1,2,2,";
	kk += "1,2,5,2,1,2,1,1,2,1,2,1,";
	kk += "2,2,2,1,2,1,2,1,1,2,1,2,";
	kk += "1,2,2,1,2,2,1,5,2,1,1,2,";
	kk += "1,2,1,2,2,1,2,1,2,2,1,2,";
	kk += "1,1,2,1,2,1,2,2,1,2,2,1,";
	kk += "2,1,1,2,3,2,2,1,2,2,2,1,";
	kk += "2,1,1,2,1,1,2,1,2,2,2,1,";
	kk += "2,2,1,1,2,1,1,2,1,2,2,1,";
	//2001
	kk += "2,2,2,3,2,1,1,2,1,2,1,2,";
	kk += "2,2,1,2,1,2,1,1,2,1,2,1,";
	kk += "2,2,1,2,2,1,2,1,1,2,1,2,";
	kk += "1,5,2,2,1,2,1,2,2,1,1,2,";
	kk += "1,2,1,2,1,2,2,1,2,2,1,2,";
	kk += "1,1,2,1,2,1,5,2,2,1,2,2,";
	kk += "1,1,2,1,1,2,1,2,2,2,1,2,";
	kk += "2,1,1,2,1,1,2,1,2,2,1,2,";
	kk += "2,2,1,1,5,1,2,1,2,1,2,2,";
	kk += "2,1,2,1,2,1,1,2,1,2,1,2,";
	//2011
	kk += "2,1,2,2,1,2,1,1,2,1,2,1,";
	kk += "2,1,6,2,1,2,1,1,2,1,2,1,";
	kk += "2,1,2,2,1,2,1,2,1,2,1,2,";
	kk += "1,2,1,2,1,2,1,2,5,2,1,2,";
	kk += "1,2,1,1,2,1,2,2,2,1,2,2,";
	kk += "1,1,2,1,1,2,1,2,2,1,2,2,";
	kk += "2,1,1,2,3,2,1,2,1,2,2,2,";
	kk += "1,2,1,2,1,1,2,1,2,1,2,2,";
	kk += "2,1,2,1,2,1,1,2,1,2,1,2,";
	kk += "2,1,2,5,2,1,1,2,1,2,1,2,";
	//2021
	kk += "1,2,2,1,2,1,2,1,2,1,2,1,";
	kk += "2,1,2,1,2,2,1,2,1,2,1,2,";
	kk += "1,5,2,1,2,1,2,2,1,2,1,2,";
	kk += "1,2,1,1,2,1,2,2,1,2,2,1,";
	kk += "2,1,2,1,1,5,2,1,2,2,2,1,";
	kk += "2,1,2,1,1,2,1,2,1,2,2,2,";
	kk += "1,2,1,2,1,1,2,1,1,2,2,2,";
	kk += "1,2,2,1,5,1,2,1,1,2,2,1,";
	kk += "2,2,1,2,2,1,1,2,1,1,2,2,";
	kk += "1,2,1,2,2,1,2,1,2,1,2,1,";
	//2031
	kk += "2,1,5,2,1,2,2,1,2,1,2,1,";
	kk += "2,1,1,2,1,2,2,1,2,2,1,2,";
	kk += "1,2,1,1,2,1,5,2,2,2,1,2,";
	kk += "1,2,1,1,2,1,2,1,2,2,2,1,";
	kk += "2,1,2,1,1,2,1,1,2,2,1,2,";
	kk += "2,2,1,2,1,4,1,1,2,1,2,2,";
	kk += "2,2,1,2,1,1,2,1,1,2,1,2,";
	kk += "2,2,1,2,1,2,1,2,1,1,2,1,";
	kk += "2,2,1,2,5,2,1,2,1,2,1,1,";
	kk += "2,1,2,2,1,2,2,1,2,1,2,1,";
	//2041
	kk += "2,1,1,2,1,2,2,1,2,2,1,2,";
	kk += "1,5,1,2,1,2,1,2,2,2,1,2,";
	kk += "1,2,1,1,2,1,1,2,2,1,2,2";
	
	var arr = new Array();
	arr = kk.split(",");
	
	return arr;
}


////////////////////////////////////////////////////////////////////////////////
// 내부에서만 사용하는 함수 End
////////////////////////////////////////////////////////////////////////////////


/*********************************************************************************************
 ★ 설명
 ★ parameter 
	그리드 전체 선택체크가 마지막엔 클리어 안됨으로 해당 메소드를 호출한다.
    1. aGpData : 그리드
 ★ 목적    
    그리드 체크 선택이 안풀린다.
 ★ 주의사항
 ********************************************************************************************/
function setHeaderChkClear(obj){
	
	var objRtn = this.all[obj.name];
	if (!objRtn){
		alert("not grid object!!! your name?");
		return;
	}
	obj.setCellProperty("head",0,"text",0);
}


/*----------------------------------------------------------------------------------
* 기능 : 체크박스 일괄선택/해제 처리함수(예외 컬럼 작동시)
* 인수 : obj(그리드 object),nCell(클릭한 셀index), sColID(사용자컬럼명)
* rtn  : 
* 주의사항: 바인딩된 데이타셋에는 반드시 사용자 Column이 존재해야 한다. 
/*----------------------------------------------------------------------------------*/
function cf_AllChk(obj,nCell,sColID)
{
	
	var nFlag = "0";
	var ds_tmp;
	
	if(parseInt(trim(obj.getCellProperty("head",nCell,"text"))) == 1){
		nFlag = "0";
	}else{
		nFlag = "1";
	}
	obj.setCellProperty("head",nCell,"text",nFlag);
	
	ds_tmp = eval(obj.binddataset);
	
	for(var i=0; i< ds_tmp.getRowCount(); i++)
	{	
		ds_tmp.setColumn(i,sColID,nFlag);
	}
}


/*
	*************************************************************
	함수명 : cf_size_Alert
	함수용도 : 데이터의 길이를 체크하고 메세지를 보여준다.
	Argument : 데이터셋, 로우, 컬럼ID, 포커스대상, 맥스사이즈
	return :   true : 정상, false : 사이즈 넘었을경우
	등록일자 : 2010. 08
	등록자 : RYU
	*************************************************************
*/ 
function cf_size_Alert(ds_obj, row, col_id, focus_obj, max_size){
	
	var data = ds_obj.getColumn(row,col_id);
	var size = parseInt(LenB(data));
	
	//var arr = Array();
	
	if (size > max_size){
		ds_obj.rowposition = row;		
		focus_obj.setFocus();
		cf_Alert("COME0001",size,max_size);  //최대입력 가능길이를 넘었습니다. (!@/!@)	
		return false;
	}
	return true;
}

/*
	*************************************************************
	함수명 : cf_size_Alert2
	함수용도 : 데이터의 길이를 체크하고 메세지를 보여준다.[ds에 focus를 주지않는다.]
	Argument : 데이터셋, 로우, 컬럼ID, 포커스대상, 맥스사이즈
	return :   true : 정상, false : 사이즈 넘었을경우
	등록일자 : 2010. 08
	등록자 : RYU
	*************************************************************
*/ 
function cf_size_Alert2(data, focus_obj, max_size){

	var size = parseInt(LenB(data));
	
	if (size > max_size){	
		focus_obj.setFocus();
		cf_Alert("COME0001",size,max_size);  //최대입력 가능길이를 넘었습니다. (!@/!@)	
		return false;
	}
	return true;
}

/*
	*************************************************************
	함수명 : cf_chk_data
	함수용도 : 데이터 필수체크
	Argument : 객체, msg타입, msg내용
	return :   true : 정상, false : 사이즈 넘었을경우
	등록일자 : 2010. 08
	등록자 : RYU
	*************************************************************
*/ 
function cf_chk_data(obj, msgCont){

	if (typeof obj !="object"){
		if(obj == null || getTrim(obj) == ""){
			cf_Alert("COME0003", msgCont);  //msgCont 은(는) 필수입니다.
			return false;
		}
		return true;
	}

	if(obj.value == null || getTrim(obj.value) == ""){
		cf_Alert("COME0003", msgCont);  //msgCont 은(는) 필수입니다.
		obj.setFocus();
		return false;
	}else{
		obj.value = getTrim(obj.value);
	}
	return true;
}




 /*-----------------------------------------------------------------------------------
 * @type   : function
 * @access : public
 * @sig    : 
 * @desc   : Global Dataset의 gds_Message와 G_LANG의 구분값에 의해 해당 언어별 메시지를
             Alert형식으로 리턴한다.             
 * 주의사항 : gds_Message + G_LANG와 동시 사용
 *---------------------------------------------------------------------------------*/

var divStr = "!@";

function cf_Alert(sMID){

	var arr = Array();
	
	for (var i=0, length=arguments.length; i<length;i++) {
		var argument = arguments[i];
		if ( i > 0 ) arr.push(argument);		
	}

	//trace("alert=>" + sMID + "arr=>" + arr);

	var errMsg = "Not Find Message!";
	var sMsg = gds_Message.lookup("MSG_CD",sMID, "MSG_VL");
	var sMtp = gds_Message.lookup("MSG_CD",sMID, "MSG_TP");
	
	if (!sMtp) sMtp = "A";
	
	if (sMsg){	
		if(arr != null && arr != ""){
			var size = arr.length;
			var nStrMsg = "";		
			
			if(size > 0){
				for(var i=0;i<size;i++){				
					var position = sMsg.indexOf(divStr);
					var divlength = LenB(divStr);
					
					if(position != -1){
						var nStrMsgStr = "";
						var nStrMsgEnd = "";
						nStrMsgStr = sMsg.substr(0,position+divlength);
						nStrMsgEnd = sMsg.substr(position+divlength);												
						sMsg = nStrMsgStr.replace(divStr,arr[i]) + nStrMsgEnd;							
					}
				}			
			}
		}	
	}else{
		sMsg = errMsg;
	}

	if (sMtp == "A"){
		//getBodyFrame().fnBodyAlert(sMsg.replace("#13","\n"));
		alert(sMsg.replace("#13","\n"));
	}else{
		//return getBodyFrame().fnBodyConfirm(sMsg.replace("#13","\n"));
		return confirm(sMsg.replace("#13","\n"));
	}	
}


/*-----------------------------------------------------------------------------------
 * @type   : cf_Confirm
 * @access : public
 * @sig    : 
 * @desc   :             
 * 주의사항 : 확인메세지창
 *---------------------------------------------------------------------------------*/

var divStr = "!@";

function cf_Confirm(sMID){

	var arr = Array();
	
	for (var i=0, length=arguments.length; i<length;i++) {
		var argument = arguments[i];
		if ( i > 0 ) arr.push(argument);		
	}

	var errMsg = "Not Find Message!";
	var sMsg = gds_Message.lookup("MSG_CD",sMID, "MSG_VL");
	
	if (sMsg){	
		if(arr != null && arr != ""){
			var size = arr.length;
			var nStrMsg = "";		
			
			if(size > 0){
				for(var i=0;i<size;i++){				
					var position = sMsg.indexOf(divStr);
					var divlength = LenB(divStr);
					
					if(position != -1){
						var nStrMsgStr = "";
						var nStrMsgEnd = "";
						nStrMsgStr = sMsg.substr(0,position+divlength);
						nStrMsgEnd = sMsg.substr(position+divlength);												
						sMsg = nStrMsgStr.replace(divStr,arr[i]) + nStrMsgEnd;							
					}
				}			
			}
		}	
	}else{
		sMsg = errMsg;
	}

	return confirm(sMsg.replace("#13","\n"));

}


/*-----------------------------------------------------------------------------------
 * @type   : cf_Msg
 * @access : public
 * @sig    : 
 * @desc   :             
 * 주의사항 : 확인메세지창
 *---------------------------------------------------------------------------------*/
function cf_Msg(sMID){
	var arr = Array();
	
	for (var i=0, length=arguments.length; i<length;i++) {
		var argument = arguments[i];
		if ( i > 0 ) arr.push(argument);		
	}

	var errMsg = "Not Find Message!";
	var sMsg = gds_Message.lookup("MSG_CD",sMID, "MSG_VL");
	
	if (sMsg){	
		if(arr != null && arr != ""){
			var size = arr.length;
			var nStrMsg = "";		
			
			if(size > 0){
				for(var i=0;i<size;i++){				
					var position = sMsg.indexOf(divStr);
					var divlength = LenB(divStr);
					
					if(position != -1){
						var nStrMsgStr = "";
						var nStrMsgEnd = "";
						nStrMsgStr = sMsg.substr(0,position+divlength);
						nStrMsgEnd = sMsg.substr(position+divlength);												
						sMsg = nStrMsgStr.replace(divStr,arr[i]) + nStrMsgEnd;							
					}
				}			
			}
		}	
	}else{
		sMsg = errMsg;
	}
		
	return sMsg;
}


/*
	상태바에 메세지 보여주기
*/
function cf_statustext(msgParam){

	var callFunction = "cf_Msg(" + wrapQuote(msgParam);	
	
	for (var i=0, length=arguments.length; i<length;i++) {
		var argument = arguments[i];		
		if (i!=0) callFunction += "," + wrapQuote(argument);		
	}
	
	callFunction += ")";
	
	try{
		getStatusFrame().all['Stc_status'].text	= eval(callFunction);
	}catch(e){
		
	}	
}


/**
 * 그리드 정렬
 * @param obj    - GRID ID
 * @param e      - 이벤트
 */
function cf_gridSort(obj, e){
	GridSort(obj, e, "▼", "▲" );
}

/**
 * function name        : setComboList
 * function description : 공통코드 조회
 * argument             : arrCombo (콤보리스트)
 *                        arrSearchKey (대분류코드값) 
 *                        arrListMode (보여주는 모드) 
 *                        arrOptionRowValue (추가문구)
 * return Type          : 
 */
function setComboList(arrCombo, arrSearchKey, arrListMode, arrOptionRowValue){

    for (var i=0,objCnt = arrCombo.length ; i<objCnt ; i++) 
    {     
		//var objCombo = this.all[arrCombo[i]];
		var tmpCombo = arrCombo[i].split(".");
		var objCombo = eval("this.all['" + tmpCombo.join("']['") + "']");
		
		var strDataset = "ds_combo" + i;
		var strSearchKey = getTrim(arrSearchKey[i]);
		
		var objDs = "";
		if (!this.all(strDataset)){
			objDs = new Dataset();
			objDs.name = strDataset;		
			this.addChild(strDataset, objDs);
		}else{
			objDs = eval(strDataset);
		}
		
        var strListMode = getTrim(arrListMode[i]);
        var strOptionRowValue = getTrim(arrOptionRowValue[i]);

        switch (strListMode) 
        {
            case "CTY" :    strListMode = "0";  break;
            case "TY"  :    strListMode = "1";  break;
            case "CTN" :    strListMode = "2";  break;
            case "TN"  :    strListMode = "3";  break;
            default    :    strListMode = "1";  break;
        }

		objDs.clearData();
		gds_CommCode.filter("GROUPCODE=="+wrapQuote(strSearchKey) + "&& USE_YN=='Y'");		
		objDs.copyData(gds_CommCode, true);
				
        if (objDs.getRowCount() <= 0) {
            if (strOptionRowValue == "") return;
        }
        
        var LeftChar = "[" , RightChar = "]";
        var strCode = "", strText = "";
        
        for (var j=0,objDsCount = objDs.getRowCount() ; j<objDsCount ; j++){			
			switch( strListMode){
				case "0" :
				case "2" :
					strText = LeftChar + objDs.getColumn(j, "CODE") + RightChar + " " +objDs.getColumn(j, "CODE_NM");
					break;
				case "1" :	
				case "3" :	
					strText = objDs.getColumn(j, "CODE_NM");
					break;
			}			
			
			objDs.setColumn(j, "CODE_NM", strText);
		}
		
        var OptionRowCd = "";           // 추가할 Row Code
        var OptionRowText = "";         // 추가할 Row Code명		
        
        if (strOptionRowValue != "") {
            var arrstrOptionRowValue = strOptionRowValue.split(",");
            OptionRowCd = arrstrOptionRowValue[0];
            if(arrstrOptionRowValue.length > 0) OptionRowText = arrstrOptionRowValue[1];
        }
         
        switch (strListMode) 
        {
            case "0" : 
            case "1" : 
            case "2" :            	
                objDs.insertRow(0);
                objDs.setColumn(0, "CODE", OptionRowCd);
                objDs.setColumn(0, "CODE_NM", OptionRowText);
                break;
        }
                 						
        objCombo.innerdataset = objDs.name;
        
        objCombo.codecolumn = "CODE";
        objCombo.datacolumn = "CODE_NM";
        objCombo.index = 0;        
	}
}

/*
	임시로그확인
*/
function cf_trace(art1, arg2){
	trace(art1 + "값 : [" + arg2 + "]");
}

	
/*
	조회데이터셋 만들기
*/
function fun_ds_srch(ds_obj, column, value){
	
	this.ds = "";
		
	if (typeof ds_obj == "string"){
		this.ds = eval(ds_obj);
	}else{
		this.ds = ds_obj;
	}
	
	this.ds.addColumn(column, "string");

	if(this.ds.rowcount <1){
		this.ds.addRow();
	}
	this.ds.setColumn(this.ds.Row, column, value);

}


/*
	*************************************************************
	사용자콤보만들기
	*************************************************************
*/
function set_user_code(){

	var cnt = ds_code_array.rowcount;		
	var	strInDatasets = ""; 
	var	strOutDatasets = "";
	var	strArgument = "";

	for (var i=0; i < cnt ; i++){
	
		var name = "ds_code_array" + i;	
		var obj = "";
		if (!this.all(name)){
			obj = new Dataset();
			obj.name = name;		
			this.addChild(name, obj);		
		}else{
			obj = eval(name);		
		}

		if(obj.rowcount == 0) {
			obj.addColumn("CODE1");
			obj.addColumn("CODE2");
			obj.addColumn("CODE3");
			obj.addRow();		
		}	
			
		obj.setColumn(0,"CODE1", ds_code_array.getColumn(i,"CODE1"));
		obj.setColumn(0,"CODE2", ds_code_array.getColumn(i,"CODE2"));
		obj.setColumn(0,"CODE3", ds_code_array.getColumn(i,"CODE3"));			
		
		strInDatasets 	+= "SELECT_" + i + "_IDATA=" + name + ":a ";
	    strOutDatasets 	+= obj.name + "=SELECT_"+ i +"_ODATA ";
		strArgument 	+= "SELECT_"+ i +"_ID=" + ds_code_array.getColumn(i,"SQL_ID") + " ";		
	}

	//거래시작	
	var	strSvcID = "R1";
	var	strURL = SVC_USR_URL;	
	var strCallbackFunc = "codeProcess";
	var strProcessBar = false;
	var strSynce = false;
	
	cf_SVC(strSvcID,strURL,strInDatasets,strOutDatasets,strArgument,strCallbackFunc,strProcessBar,strSynce);

	for (var i=0; i < cnt ; i++){

		//var cb_obj = this.all[ds_code_array.getColumn(i,"COMBO_NAME")];				
		var tmpCombo = (ds_code_array.getColumn(i,"COMBO_NAME")).split(".");
		var cb_obj = eval("this.all['" + tmpCombo.join("']['") + "']");			
			
			
		var ds_obj = this.all["ds_code_array" + i];	
		var option = ds_code_array.getColumn(i,"OPTION");	

        cb_obj.innerdataset = ds_obj.name;
        
        cb_obj.codecolumn = "CODE";
        cb_obj.datacolumn = "CODE_NM";			
		
		var hig_code = ds_obj.getColumn(0,"HIG_CODE");
		
		if (option != ""){
			ds_obj.insertRow(0);							
			if (option == 1){
				ds_obj.setColumn(0,"HIG_CODE","");
				ds_obj.setColumn(0,"CODE","");	
				ds_obj.setColumn(0,"CODE_NM","전체");
			}else if (option == 2){
				ds_obj.setColumn(0,"HIG_CODE","");
				ds_obj.setColumn(0,"CODE","");	
				ds_obj.setColumn(0,"CODE_NM","선택");															
			}
			
		}
		cb_obj.index = 0; 
	}	
}

function codeProcess(){
}

/**
 * function name        : getTrim
 * function description : 문자열 Trim 함수
 * argument             : trim 할값
 * return Type          : ""
 */
function getTrim(arg)
{
	var str = new String(arg);
	if ( str == null || str == "null") return "";
	if ( new String(str).valueOf() == "undefined") return "";
    if ( new String(str) == null ) return "";	
	
	return str.replace(/(^\s*)|(\s*$)/g, "");
}




 /*-----------------------------------------------------------------------------------
 * @type   : function
 * @access : public
 * @sig    : SvcID,sUrl,inDS,outDS,sArg,sCallbackFunc,bWait
 * @desc   : Transaction 공통 모듈               
 * @param  : @SvcID  - Transaction 고유ID       
 * @param  : @sUrl   - 입력값으로 보낼 Http Path
 * @param  : @inDS   - 입력값으로 보낼 Dataset ID list
 * @param  : @outDS  - 처리 결과를 받을 Dataset의 ID List
 * @param  : @sArg   - Dataset 외의 Transaction을 위한 인자값
 * @param  : @sCallbackFunc - Transaction의 결과를 돌려줄 Function의 이름 (없으면 공통만 처리)
 * @param  : @bWait - '처리중입니다 등 처리메시지 출력여부(treu/false)
 * @param  : @bRealFlag - 동기여부 [true : 비동기, false 동기]
 * @param  : @bErrorMsgFlag - 에러메세지 출력여부[true : 공통메세지처리, false: 자체 callback처리]
 *---------------------------------------------------------------------------------*/
var DEFAULT_HOST 	  = G_SMILE2WEB;
var DEFAULT_INDATASET = "GDS_USER=gds_User";
var TEMP_OUTDATASET = "ds_InterfaceXml=DS_RETXML";

function cf_SVC(SvcID,sUrl,inDS,outDS,sArg,sCallbackFunc,bWait, bRealFlag, bErrorMsgFlag){
<<<<<<< .mine

	if (!bWait) {
		trace("loding=>", bWait);
		cf_SVC_back(SvcID,sUrl,inDS,outDS,sArg,sCallbackFunc,bWait, bRealFlag, bErrorMsgFlag);
		return;
	}
=======
>>>>>>> .r5752

	if (!bWait) {
		cf_SVC_back(SvcID,sUrl,inDS,outDS,sArg,sCallbackFunc,bWait, bRealFlag, bErrorMsgFlag);
		return;
	}

	var strDataset = "ds_InterfaceXml";
	var objOutDs = "";
	if (!this.all(strDataset)){
		objOutDs = new Dataset();
		objOutDs.name = strDataset;		
		this.addChild(strDataset, objOutDs);
	}
	ds_InterfaceXml.clearData();

	//세션시간 초기화	
	if(this.name == "COM010" || gds_User.rowcount < 1 || SvcID == "TOP_ALAM" || SvcID == "TOP_MINI" ){
	}else{
		getTopFrame().sessionTimerReset();
	}

	var sSVCURL="";
	var sArgument="";
	var sINDATASETS="";
	var sOUTDATASETS="";

	//sSVCURL = "SMILE2WEB::" + sUrl;
	
	var ifyn = (SvcID).indexOf("IF");	
	if (ifyn > -1){
		sSVCURL = "INTERFACE_TEST::" + sUrl;		
	}else{
		sSVCURL = "SMILE2WEB::" + sUrl;
	}
	
	//trace("sSVCURL :: " + sSVCURL);
	
	if (typeof bRealFlag == "undefined" ){
		bRealFlag = true;
	}

	if (typeof bRealFlag == "undefined" ){
		bErrorMsgFlag = true;
	}
		
	sArgument = sArg;
	sINDATASETS = DEFAULT_INDATASET + " " + inDS; // 사용자정보데이타셋 추가
	sOUTDATASETS = outDS + " " + TEMP_OUTDATASET;	
	
	//setWaitCursor(true,true);
	//CLASS_TYPE_WAITCURSOR = bWait;
	//trace("CLASS_TYPE_WAITCURSOR==>" + CLASS_TYPE_WAITCURSOR);
	setWaitCursor(true,true);
	
	/*
	if (CLASS_TYPE_WAITCURSOR != undefined && CLASS_TYPE_WAITCURSOR == true) {				
		setWaitCursor(true,true);
	}else{
		setWaitCursor(false,true);
	}
	*/
	
	
	transaction(	SvcID + ":::" + sCallbackFunc +":::"+ bWait + ":::" + bErrorMsgFlag,
					sSVCURL		,					
					sINDATASETS	,
					sOUTDATASETS,
					sArgument	,
					"cf_TrCallBack"
					, bRealFlag							
	);
}


function cf_viewDataSet(ds) {
	if(ds==null || ds=="") {
		var arrParam = {getDsArgument:eval("ds_InterfaceXml")};
		PopupDialog("DATASETVIEW", "Base::DATASETVIEW.xfdl", -1, -1, 1024, 768, false, -1, arrParam, true);
	} else {
		var arrParam = {getDsArgument:ds};
		PopupDialog("DATASETVIEW", "Base::DATASETVIEW.xfdl", -1, -1, 1024, 768, false, -1, arrParam, true);
	}
}




function cf_TrCallBack(sSvcID,nErrorCode,strErrorMsg){

	//if (CLASS_TYPE_WAITCURSOR == true)	 setWaitCursor(false,true);
	setWaitCursor(false,true);
	
	if(nErrorCode==0) {
		if(ds_InterfaceXml.rowcount>0) {
			var row = gds_InterFaceData.addRow();
			gds_InterFaceData.copyRow(row, ds_InterfaceXml, 0);
		}
	}
	
	
	var sArrParams = sSvcID.split(":::");
	
	var bErrorMsgFlag = sArrParams[3];
	
	//에러메세지를 자동으로 보여준다.
	if (bErrorMsgFlag != "false"){
	
		switch (nErrorCode)
		{
			case "0" : // none error
				cf_statustext("COMI0001");
				break;
			case "-1" : // 응답시간초과
				cf_statustext("COME0002", "응답시간이 초과하였습니다. \n\n 관리자에게 문의하세요.");
				break;				
			default :
				cf_statustext("COME0002", "오류[" + nErrorCode + "]");
				break;		
		}
		
		switch (nErrorCode)
		{
			case "0" : // none error
				eval(sArrParams[1] + "('" + sArrParams[0] + "', nErrorCode, strErrorMsg);");
				break;
			case "-1" : // 응답시간초과
				alert("응답시간이 초과하였습니다. \n\n 관리자에게 문의하세요.");								
				break;				
			default :
				cf_Alert("COME0002", strErrorMsg);
				break;		
		}
	//에러메세지를 수동으로 보여준다.
	}else{	
		eval(sArrParams[1] + "('" + sArrParams[0] + "', nErrorCode, strErrorMsg);");		
	}		
}

/*
	백그라운드
*/
function cf_SVC_back(SvcID,sUrl,inDS,outDS,sArg,sCallbackFunc,bWait, bRealFlag, bErrorMsgFlag){
<<<<<<< .mine

	trace("#################cf_SVC_back#################");
	trace("SvcID          = " +       SvcID         );
	trace("sUrl           = " +       sUrl          );
	trace("inDS           = " +       inDS          );
	trace("outDS          = " +       outDS         );
	trace("sArg           = " +       sArg          );
	trace("sCallbackFunc  = " +       sCallbackFunc );
	trace("bWait          = " +       bWait         );
	trace("bRealFlag      = " +       bRealFlag     );
	trace("bErrorMsgFlag  = " +       bErrorMsgFlag );
	
	var strDataset = "ds_InterfaceXml";
	var objOutDs = "";
	if (!this.all(strDataset)){
		objOutDs = new Dataset();
		objOutDs.name = strDataset;		
		this.addChild(strDataset, objOutDs);
	}
	ds_InterfaceXml.clearData();

	//세션시간 초기화	
	if(this.name == "COM010" || gds_User.rowcount < 1 || SvcID == "TOP_ALAM" || SvcID == "TOP_MINI" ){
	}else{
		getTopFrame().sessionTimerReset();
	}

	var sSVCURL="";
	var sArgument="";
	var sINDATASETS="";
	var sOUTDATASETS="";
	
	var ifyn = (SvcID).indexOf("IF");	
	if (ifyn > -1){
		sSVCURL = "INTERFACE_TEST::" + sUrl;		
	}else{
		sSVCURL = "SMILE2WEB::" + sUrl;
	}
	
	if (typeof bRealFlag == "undefined" ){
		bRealFlag = true;
	}

	if (typeof bRealFlag == "undefined" ){
		bErrorMsgFlag = true;
	}
		
	sArgument = sArg;
	sINDATASETS = DEFAULT_INDATASET + " " + inDS; // 사용자정보데이타셋 추가
	sOUTDATASETS = outDS + " " + TEMP_OUTDATASET;	
	
	transaction(	SvcID + ":::" + sCallbackFunc +":::"+ bWait + ":::" + bErrorMsgFlag,
					sSVCURL		,					
					sINDATASETS	,
					sOUTDATASETS,
					sArgument	,
					"cf_TrCallBack_back"
					, bRealFlag							
=======

	var strDataset = "ds_InterfaceXml";
	var objOutDs = "";
	if (!this.all(strDataset)){
		objOutDs = new Dataset();
		objOutDs.name = strDataset;		
		this.addChild(strDataset, objOutDs);
	}
	ds_InterfaceXml.clearData();

	//세션시간 초기화	
	if(this.name == "COM010" || gds_User.rowcount < 1 || SvcID == "TOP_ALAM" || SvcID == "TOP_MINI" ){
	}else{
		getTopFrame().sessionTimerReset();
	}

	var sSVCURL="";
	var sArgument="";
	var sINDATASETS="";
	var sOUTDATASETS="";
	
	var ifyn = (SvcID).indexOf("IF");	
	if (ifyn > -1){
		sSVCURL = "INTERFACE_TEST::" + sUrl;		
	}else{
		sSVCURL = "SMILE2WEB::" + sUrl;
	}
	
	if (typeof bRealFlag == "undefined" ){
		bRealFlag = true;
	}

	if (typeof bRealFlag == "undefined" ){
		bErrorMsgFlag = true;
	}
		
	sArgument = sArg;
	sINDATASETS = DEFAULT_INDATASET + " " + inDS; // 사용자정보데이타셋 추가
	sOUTDATASETS = outDS + " " + TEMP_OUTDATASET;	
	
	transaction(	SvcID + ":::" + sCallbackFunc +":::"+ bWait + ":::" + bErrorMsgFlag,
					sSVCURL		,					
					sINDATASETS	,
					sOUTDATASETS,
					sArgument	,
					"cf_TrCallBack_back"
					, bRealFlag							
>>>>>>> .r5752
	);
}

function cf_TrCallBack_back(sSvcID,nErrorCode,strErrorMsg){
	
	if(nErrorCode==0) {
		if(ds_InterfaceXml.rowcount>0) {
			var row = gds_InterFaceData.addRow();
			gds_InterFaceData.copyRow(row, ds_InterfaceXml, 0);
		}
	}	
	
	var sArrParams = sSvcID.split(":::");
	
	var bErrorMsgFlag = sArrParams[3];
	
	//에러메세지를 자동으로 보여준다.
	if (bErrorMsgFlag != "false"){
	
		switch (nErrorCode)
		{
			case "0" : // none error
				cf_statustext("COMI0001");
				break;
			case "-1" : // 응답시간초과
				cf_statustext("COME0002", "응답시간이 초과하였습니다. \n\n 관리자에게 문의하세요.");
				break;				
			default :
				cf_statustext("COME0002", "오류[" + nErrorCode + "]");
				break;		
		}
		
		switch (nErrorCode)
		{
			case "0" : // none error
				eval(sArrParams[1] + "('" + sArrParams[0] + "', nErrorCode, strErrorMsg);");
				break;
			case "-1" : // 응답시간초과
				alert("응답시간이 초과하였습니다. \n\n 관리자에게 문의하세요.");								
				break;				
			default :
				cf_Alert("COME0002", strErrorMsg);
				break;		
		}
	//에러메세지를 수동으로 보여준다.
	}else{	
		eval(sArrParams[1] + "('" + sArrParams[0] + "', nErrorCode, strErrorMsg);");		
	}	
}


<<<<<<< .mine

=======




>>>>>>> .r5752
/**
 * function name        : PopupDialog
 * function description : 공통 Modal Dialog를 실행 한다.
 * parameter 1. strId   : Dialog ID
             2. strURL  : Form URL
             3. nTop    : Form TOP Position
             4. nLeft   : Form Left Position
             5. nWidth  : Form Width
             6. nHeight : Form Height
             7. isShowTitle : Form Title 을 표시 할지 여부
             8. strAlign: Dialog 의 위치 - '-1' : 모니터의 중앙
                                          - 'Bottom Left' : Click 된 마우스 위치의 좌측 하단 정렬
                                          - 'Top Left' : Click 된 마우스 위치의 좌측 상단 정렬
                                          - 'Bottom Right' : Click 된 마우스 위치의 우측 하단 정렬
                                          - 'Top Right' : Click 된 마우스 위치의 우측 상단 정렬
                                          - 'offset' : Click 된 마우스 위치에서 nTop,nLeft만큼 들여쓰기.
                                          - 'absolute' : 입력된 좌표를 Screen 좌표로 인식.(손영기)
                                          - '0' : 사용자 임의 정렬
             9. strArgument : Dialog 로 전달될 Argument - {strMessage1:'E'}
            10. isModeless : 10번째 true 면 Dialog 를 Modeless로 띄운다.
            11. isLayered : 11번째 true 면 Dialog 를 Layered로 띄운다.
            12. isAutoSize : 12번째 false 면 앞에서 선언한 사이즈로 올라온다.
            13. isResize  : 13번째 true 면 resize가 가능하게 올라온다.
 * return true/false - 적합 / 부적합
 */
function PopupDialog(strId, strURL, nTop, nLeft, nWidth, nHeight, isShowTitle, strAlign, strArgument, isModeless, isLayered, isAutoSize, isResize)
{
    var newChild = null;
    var objParentFrame = this.getOwnerFrame();

    var nRight = 0;
    var nBottom = 0;

    if (strAlign == "Bottom Left") {
        nLeft = system.cursorx;
        nBottom = system.cursory - 5;
        nTop = nBottom - nHeight;
        nRight = nLeft + nWidth;
    }
    else if (strAlign == "Top Left") {
        nTop = system.cursory - 5;
        nLeft = system.cursorx;
        nBottom = nTop + nHeight;
        nRight = nLeft + nWidth;
    }
    else if (strAlign == "Bottom Right") {
        nRight = system.cursorx;
        nBottom = system.cursory - 5;
        nTop = nBottom - nHeight;
        nLeft = nRight - nWidth;
    }
    else if (strAlign == "Top Right") {
        nTop = system.cursory - 5;
        nRight = system.cursorx;
        nBottom = nTop + nHeight;
        nLeft = nRight - nWidth;
    }
    else if (strAlign == "-1") {
        
        var strScreenRes = system.getScreenResolution(1);
        var nCenterX = new Number(strScreenRes.split(" ")[0]);
        var nCenterY = new Number(strScreenRes.split(" ")[1]);
        
        var nMarginX = 0;
        var nMoniterIndex = system.getMonitorIndex(system.cursorx, system.cursory);
        
        if (nMoniterIndex == 2) {
            var strMarginRes = system.getScreenResolution(1);
            nMarginX = new Number(strMarginRes.split(" ")[0]);
        }
        
        nTop = Math.round(mainframe.position.height / 2) - Math.round(nHeight / 2) + mainframe.position.top;
        nLeft = Math.round(mainframe.position.width / 2) - Math.round(nWidth / 2) + mainframe.position.left;
        nBottom = nTop + nHeight;
        nRight = nLeft + nWidth;
    }
    else if (strAlign == "offset") {
        nTop += system.cursory;
        nLeft += system.cursorx;
        nBottom = nTop + nHeight;
        nRight = nLeft + nWidth;
    }
    else if (strAlign == "absolute")
    {
        nBottom = nTop + nHeight;
        nRight = nLeft + nWidth;
    }
    else {
        nTop   += mainframe.position.top;
        nLeft  += mainframe.position.left;
        nBottom = nTop + nHeight;
        nRight  = nLeft + nWidth;
    }

    /**
     * 화면 밖으로 벗어나는 Dialog 방지 - Sonyk
     */

    var nMonitor = system.getMonitorIndex((nLeft+nRight)/2,(nTop+nBottom)/2);
    var rectScreen = system.getScreenRect(nMonitor);

    if (nBottom > rectScreen.bottom) {
        nTop = rectScreen.bottom - (nBottom - nTop);
        nBottom = rectScreen.bottom;
    }

    if (nTop < rectScreen.top) {
        nBottom = rectScreen.top + (nBottom - nTop);
        nTop = rectScreen.top;
    }

    if (nRight > rectScreen.right) {
        nLeft = rectScreen.right - (nRight - nLeft);
        nRight = rectScreen.right;
    }

    if (nLeft < rectScreen.left) {
        nRight = rectScreen.left + (nRight - nLeft);
        nLeft = rectScreen.left;
    }
    
    // 여기까지 - Sonyk

    newChild = new ChildFrame;
    newChild.init(strId, nLeft, nTop, nRight, nBottom, strURL);

    if (isLayered == true) {
        newChild.layered = true;
    }
    else {
        newChild.layered = false;
    }

    newChild.style.border.width = "0";
    newChild.showstatusbar = false;
    newChild.style.border = "1 solid #65a1c4ff";
    newChild.resizable = (isResize||false);

    if (isAutoSize == false) newChild.autosize = false;
    else newChild.autosize = true;

    if (!isShowTitle) newChild.showtitlebar = false;
    
    if (isModeless == true) {    
        return newChild.showModeless(objParentFrame, strArgument);
    }
    else {    
        var rtn = newChild.showModal(objParentFrame, strArgument);
        return rtn;
    }
}

function cf_isNull(argValue){
	if (getTrim(argValue) == "") return true;	
	return false;
}


/**
 * 전화번호형식으로 리턴 
 * ###-####-####
 */ 
function maskPhone(strValue)
{
	var strTemp = getTrim(strValue).replace(/\-/g,"");
	if(strValue.substr(0,1) == "0"){
		var oRegExp = /(\d{2,3})(\d{3,4})(\d{4})/;
		if(strTemp.length >= 2){
			if(strTemp.substring(0,2) == "02")
				oRegExp = /(\d{2})(\d{3,4})(\d{4})/;
		}
		return(strTemp.replace(oRegExp, "$1-$2-$3"));
	}else{
		var oRegExp = /(\d{3,4})(\d{4})/;
		return(strTemp.replace(oRegExp, "$1-$2"));
	}
}

/**
 *
 * 마스크에디트의 비밀번호 mask속성값 리턴
 * 
 */
function maskPassWord(strValue)
{
	var intLength = strValue.length;
	var strMsk = "{";
	for(i=0; i<intLength; i++)
	{
		strMsk = strMsk + "@";
	}
	strMsk = strMsk + "}";
		
	return strMsk;
}

//DB날짜를 가져온다
function getToday(){
	return GetUserInfo("gTODAY");
}

//공통TOP_FRMAE주소를 가져온다.
function getTopFrame(){
	return application.mainframe.VFrameSet.TopFrame.form;
}

//공통TOP_FRMAE주소를 가져온다.
function getTabFrame(){
	return application.mainframe.VFrameSet.TabFrame.form;	
}

//공통Body_FRMAE주소를 가져온다.
function getBodyFrame(){
	return application.mainframe.VFrameSet.BodyFrame.all[0].form;	
}

//공통TOP_FRMAE주소를 가져온다.
function getStatusFrame(){
	return application.mainframe.VFrameSet.StatusFrame.form;	
}

//탭포커스준다.
function getTabFocus(prg_id){	
	if (prg_id =="HOME") {
		getTabFrame().all['tab_mdititle'].tabindex = 0;		
		return;
	}
	var nRow = gds_OpenPage.findRow("formid" , prg_id);					
	getTabFrame().lf_ActiveTitle(prg_id);
	getTabFrame().tab_mdititle_change(nRow);
	
}

//공통TOP_FRMAE에 있는 폰객체를 얻어온다.
function getObjPhnBns(){
	return application.mainframe.VFrameSet.TopFrame.form.Div_CTI.objPHNBNS;
}

function getObjPhnOrd(){
	return application.mainframe.VFrameSet.TopFrame.form.Div_CTI.objPHNORD;
}

function getObjPhnLps(){
	return application.mainframe.VFrameSet.TopFrame.form.Div_CTI.objPHNLPS;
}

function getObjPhnCmp(){
	return application.mainframe.VFrameSet.TopFrame.form.Div_CTI.objPHNCMP;
}

function getObjPhnDtmf(){
	return application.mainframe.VFrameSet.TopFrame.form.Div_CTI.objPHNDTMF;
}


	
/*
	DB거래를 이용하여 년월일시를 가져온다.
*/
function getDBToday(){

	var name = "ds_date" ;	
	var obj = "";
	if (!this.all(name)){
		obj = new Dataset();
		obj.name = name;		
		this.addChild(name, obj);		
	}else{
		obj = eval(name);		
	}
	
	var	strSvcID = "R1";
	var	strURL = SVC_USR_URL;	
	var	strInDatasets = ""; 
	var	strOutDatasets = "ds_date=SELECT_0_ODATA";
	var	strArgument = "SELECT_0_ID=Common.Get_HASH_DATE_SELECT";
	var strCallbackFunc = "codeProcess";
	var strProcessBar = false;
	var strSynce = false;
	
	cf_SVC(strSvcID,strURL,strInDatasets,strOutDatasets,strArgument,strCallbackFunc,strProcessBar,strSynce);

	return ds_date.getColumn(0,"SEQ");
}	

	
/*
	DB거래를 이용하여 년월일시를 가져온다.
*/
function getMSToday(){

	var name = "ds_MSdate" ;	
	var obj = "";
	if (!this.all(name)){
		obj = new Dataset();
		obj.name = name;		
		this.addChild(name, obj);		
	}else{
		obj = eval(name);		
	}
	
	var	strSvcID = "R1";
	var	strURL = SVC_USR_URL;	
	var	strInDatasets = ""; 
	var	strOutDatasets = "ds_MSdate=SELECT_0_ODATA";
	var	strArgument = "SELECT_0_ID=Common.Get_DATETIME_SELECT";
	var strCallbackFunc = "codeProcess";
	var strProcessBar = false;
	var strSynce = false;
	
	cf_SVC(strSvcID,strURL,strInDatasets,strOutDatasets,strArgument,strCallbackFunc,strProcessBar,strSynce);

	return ds_MSdate.getColumn(0,"SEQ");
}	

/*
	**********************************************************************************
	함수명 : cf_ValidDate
	함수용도 : 날짜의 정합성 체크.
	Argument : strStart, strEndDt, checkDt(default: 일자 필수 조건  N:From-To 정합성만 체크)
	return :   true : 정상, false : 오류 사유
	등록일자 : 2010. 10
	등록자 : 
	**********************************************************************************
*/  
function cf_ValidDate(strStartDt, strEndDt, checkDt)	{
	if(checkDt == 'N'){		
		if(cf_isNull(strStartDt) && strEndDt != null){
			cf_Alert("COME0007", "시작일"); 					//시작일을(를) 입력하셔야합니다.
			return false;
		}else if(strStartDt != null && cf_isNull(strEndDt)){
			cf_Alert("COME0007", "종료일");					//종료일을(를) 입력하셔야합니다.		
			return false;
		}		
		if(strStartDt - strEndDt  > 0){			
			cf_Alert("CAME0006", "종료일", "시작일");			//시작일 보다 종료일가(이) 더 큽니다.
			return false;
		}
	}else{
		if(cf_isNull(strStartDt) && cf_isNull(strEndDt)){
			cf_Alert("COME0018", "시작일", "종료일"); 		//시작일과 종료일을 입력해 주세요.
			return false;
		}else if(cf_isNull(strStartDt)){
			cf_Alert("COME0007", "시작일"); 					//시작일을(를) 입력하셔야합니다.
			return false;
		}else if(cf_isNull(strEndDt)){
			cf_Alert("COME0007", "종료일");					//종료일을(를) 입력하셔야합니다.		
			return false;
		}	
		if(strStartDt - strEndDt  > 0){			
			cf_Alert("CAME0006", "종료일", "시작일");			//시작일 보다 종료일가(이) 더 큽니다.
			return false;			
		}
		
	}

return true;
}
]]></Script>
